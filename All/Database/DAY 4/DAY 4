


							DAY 4
							
							
TOPICS COVERED :
		DDL 
			ALTER 
			DROP
			CREATE
		CONTRAINTS 
			PRIMARY KEY 
			FOREIGN KEY 
			DEFAULT 
			NOT NULL 
			UNIQUE 
			ENUM
			CHECK
			AUTO_INCREMENT
			
			
			** DDL ARE AUTOCOMMIT IN NATURE 
			
				** DML COMMANDS REQUIRED COMMIT TO PUSH THE DATA FROM TEMP TO PHYSICAL LOCATION
				

				COMMIT / ROLLBACK 
				
				COMMIT : PUSH THE DATA 
				ROLLBACK : REVERT THE DATA FROM TEMP MEMORY TILL LAST COMMIT OR DDL STATEMENTS
				
				
			
------------------------------------------------------------------------

DML : DATA MANIPULATION LANGUAGE 

	DIRECTLY IMPACT ONLY ON THE DATA 
	
	INSERT / UPDATE / DELETE 
	
	INSERT : 
			 * USED TO INSERT THE NEW RECORDS IN THE TABLE 
			 * INSERT COMMAND ALWAYS INSERT ALL THE VALUES OF THE COLUMNS EXIST IN THE TABLE 
			 
	SYNTAX : 
		
			INSERT INTO TABLENAME VALUES(VALUES WITH COMMA SEPERATED);
			
			RULES : 
				* NON OF THE COLUMNS IN THE ABOVE SYNTAX SHOULD MISSED TO ENTER 
				* SEQUENCE OF MENTIONING THE COLUMN VALUE MUST BE THE SAME AS THE TABLE STRUCTURE 
				
			CREATE TABLE EMPINSERT
			(
			ID INT,
			NAME VARCHAR(20),
			DOB DATETIME,
			SALARY INT
			)
				
			INSERT INTO EMP VALUES(INT,VARCHAR(20),DATETIME,INT);

			CAN NOT INSERT FOR ABOVE TABLE 
				LIKE 
			INSERT INTO EMP VALUES('RAHUL',101,'2021-02-02',34334);
				
			
** CORRECT INSERT INTO EMP VALUES(101,'RAHUL','2021-02-02',433434);

	==============================================================

SCENARIO : TABLE HAVE 50 COLUMNS AND I ONLY HAVE 5 VALUE TO INSERTED AND THERE ARE NO OTHER VALUES WHICH ARE MANDATORY 


	SYNTAX : 
	
		INSERT INTO TABLENAME(COLUMNS SEPERATED WITH COMMA) VALUES(VALUES IN THE SAME STRUCTURE YOU MENTIONED AFTER THE TABLE NAME SEPERATED WITH COMMA);
		
		
		INSERT INTO EMPINSERT(ID,NAME,SALARY) VALUE(101,'RITESH',80000);
		
		** VALUES MENTIONED IN THE INSERT PUSHED TO THE DATABASE IN THE RESPECTIVE COLUMNS
		** REST ALL THE COLUMN WILL HAVE NULL VALUES 
		
		
		INSERT INTO EMPINSERT(ID,NAME,SALARY) VALUE(80000,'NIKHIL',102);
		
	----------------------------------------------------------------

HOW DO WE INSERT MULTIPLE RECORDS IN THE TABLE :-

		OPEN SOURCE DATABASES PROVIDE THE PROVISION TO INSERT MULTIPLE RECORDS WITH INSERT COMMAND 
		
		INSERT INTO TABLENAME VALUES(VALUES SEPERATED WITH COMMA),(VALUES SEPERATED WITH COMMA);
		
		
		INSERT INTO EMPINSERT(ID,NAME,SALARY) VALUES(104,'SUNITA',9000),
		(105,'SHIPA',50000),(106,'KRISHAN',8444);
		
------------------------------------------------------------------------

2) UPDATE 
			: COMMAND IS USED TO UPDATE THE EXISTING DATA OF THE TABLE 
			
			** POWERFULL COMMAND 
			
			SYNTAX :: 
					UPDATE TABLENAME SET KEY COLUMN = VALUE ;
					
					OR 
					
					UPDATE TABLENAME SET KEYCOLUMN1 = VALUE,KEYCOLUMN2 = VALUE;
					
			* POWERFULL COMMAND 
				IF YOU EXECUTE THE UPDATE COMMAND WITHOUT THE CONDITION 
					IT WILL UPDATE THE COMPLETE COLUMN WITH THE SAME VALUE MENTIONED AT THE TIME UPDATE EXECUTION
					
			UPDATE EMPINSERT SET DOB = '1987-02-02';
			
			WHENEVER YOU EXECUTE UPDATE DO MENTION CONDITION
			
			UPDATE THE SALARY OF EMPLOYEE 101 
			
			SYNTAX  : 
				UPDATE TABLENAME SET COLUMN = VALUE WHERE CONDITION;
				
				UPDATE EMPINSERT SET SALARY = 5000 WHERE ID = 101;
				
					EXECUTION 
					* EMPINSERT AND FOUND THE RCORDS MACHES THE CONDITION 
						ID = 101 
					* PULL ALL THOSE RECORDS IN THE TEMP MEMORY 
					* UPDATE THE SALARY = 5000
					* PUSH THE DATA TO THE DATABASE 
					
	---------------------------------------------------------

		UPDATE EMPINSERT SET SALARY = 4000,DOB = '1987-03-03' WHERE ID = 104;
					
			*
				UPDATE COMMAND WTH MULTIPLE COLUMN ALWAYS UPDATE SINGLE RECORD 
				CONDITION RETURN MORE THEN ONE RECORD - ALL THE RETUNED RECORDS WILL BE UPDATED BY THE VALUES 
				
--------------------------------------------------------------------------

3) DELETE 
		:	 DELETE COMMAND IS USED TO DELETE THE COMPLETE RECORD FROM THE TABLE 
			* POWERFULL COMMAND AND NEED LITLE PRECAUTION TO EXECUTE 
			
				* DELETE COMMAND WITHOUT CONDITION DELETE COMPLETE TABLE 
					ONLY LEFT STRUCTURE 
					
		SYNTAX : 
			
				DELETE FROM TABLENAME WHERE CONDITION ;
				
				DELETE FROM EMPINSERT;

			* FEW THINGS ATTACH TO DELETE 
				* REMOVES THE COMPLETE RECORD FROM THE TABLE 
				* REMOVE THE RECORD - IT WONT REMOVE THE SPACE ALLOCATED TO IT 
				
		** TRUNCATE : 
				TRUNCATE ALSO REMOVES DATA FROM  THE TABLE 
					
	DELETE 									TRUNCATE 

DELETE COMMAND REMOVES RECORDS			TRUNCATE COMMAND REMOVES RECORDS
DELETE COMMAND COMES WITH 				TRUNCATE - NO CONDITION
CONDITION 	 					
										TRUNCATE USED TO REMOVE ALL THE RECORDS OF THE TABLE 
DELETE NEVER RELEASE THE SPACE 			TRUNCATE REMOVE DATA AND RELEASE 
ALLOCATED TO THE ROWS					THE SPACE AS WELL	
					
					
	SYNTAX : 

			TRUNCATE TABLE EMPINSERT; 
					
----------------------------------------------------------------------


	DML WORKS : 
			ON THE DATA 
			THESE ARE NOT AUTOCOMMIT IN NATURE 
			SYSTEM REQUIRED EXPLICITLY COMMIT TO PUSH THE DATA FROM TEMP TO MAIN TABLES
			
			INSERT 
			
			UPDATE 
			
			DELETE 
			
================================================================

DQL : 
		SELECT 
			WHICH IS VER POWERFULL COMMAND 
				AND MOSTLY USED COMMAND 
				90% OF INDUSTRY PEOPLE ONLY USE THIS COMMAND 
				
			* FETCH DATA FROM THE DATABASE 
			* SELECT COMMAND NERVER EVER TOUCH THE DATA DATA (MODIFY THE DATA OR STRUCTURE)
			* GET THE DATA 
			
			IMPACT ANYTHING IN DATABASE
			
			
	SYNTAX : 
			SELECT * FROM TABLENAME; 
			
			
				SELECT  : COMMAND (MILLIONS OF LINES OF CODE,C,C++)
				*  		: ALL THE COLUMNS OF THE TABLE 
				FROM 	: KEYWORDS INDICATES ABOUT THE TABLENAME 
				TABLENAME :	TABLE FROM WHERE WE NEED TO FETCH THE DATA 
				
			
			SELECT * FROM EMPINSERT;
			
				* RETURNS ALL THE ROWS AND COLUMNS IN THE OUTPUT 
				
	** 
		RESTRICT TO BRING CERTAINT COLUMNS FROM THE TABLE IN THE OUTPUT 
		
			SELECT COLUMNNAME SEPERATED WITH COMMA FROM TABLENAME;
			
			** SELECT  -----------------------------MANDATORY 
					EMPLOYEE_ID,FIRST_NAME,LAST_NAME,SALARY 
						FROM  ----------------------MANDATORY 
							EMPLOYEES;
			
			** SELECT 
				LAST_NAME,FIRST_NAME,SALARY, HIRE_DATE 
					FROM 
						EMPLOYEES;
			
			* THIS DOESN'T MEANS THAT IT DOING ANY CHANGES IN THE TABLE 
			NO NO NO 
				JUST FOR MY OUTPUT 
					ITS BRINGING THE DATA AND PUBLISHING ON MY SCREEN
					
--------** 
			IF NEED TO RESCTRICT THE ROWS FROM THE TABLE 
			
				INTRODUCE A WHERE CLAUSE 
				
			WHERE CLAUSE : 
					IS A PART OF THE SELECT STATEMENT
					IS THE FIRST CLAUSE EXECUTED IN THE COMPLETE SELECT STATEMENT 
					DO DIRECT FILTER FROM THE DATABASE 

					
					
	CLIENT  >>>   SERVER  >>> TEMP MEM (PROCESSING)
				
					
			SELECT 
				COLUMN NAME SEPERATED WITH COMMA 
					FROM 
						TABLENAME 
							WHERE 
								CONDITION 
								
								
CONDITION : 
		OPERATORS :
				KEY AND VALUE ATTACH TO IT 
				
					WHERE ID = 101
					ID : KEY 
					101 : VALUE 
					= : OPERATOR 
					
		RATIONAL OPERATORS : 
			
					=, <, > , <=, >= , <> , != 
					
	
	YOU NEED TO FIND THE EMPLOYEES BELONGS TO DEPARTMENT 20 
	
		* ALL THE EMPLOYEES COLUMNS 
		* REQUIRED ONLY THOSE ROWS WHERE DEPARTMENT_ID = 20 
		
		SELECT 
			* 
			FROM EMPLOYEES 
				WHERE 
					DEPARTMENT_ID = 20 ;
					
	EXECUTION :
			* FILTER THE DATA FROM THE DATABASE BASD ON THE CONDITION 
				DEPARTMENT_ID = 20
			* WHICH EVER THE ROWS MATCHES - RETURNED TO THE TEMP MEMORY 
			* THERE IT CREATE A TEMP TABLE WITH ALL THE DATA 
			* THROWS THE OUTPUT TO THE SCREEN 
			
			
		SELECT 
			FIRST_NAME,LAST_NAME, SALARY 
			FROM EMPLOYEES 
				WHERE 
					DEPARTMENT_ID = 20 ;
			
			
************************

	WHERE MULTIPLE CONDITION TAKE PLACE 
		
		NEED TO FIND THE EMPLOYEES BELONGS TO DEPARTMENT 80 
			ALONG WITH THAT NEED TO FILTER DATA BASED ON THE SALARY 
				SALARY MUST BE GREATER THE 6000 
				
			* REQUIRED ALL THE COLUMNS OF EMPLOYEE TABLE 
			* TWO CONDITION	
				DEPARTMENT_ID = 80 
				SALARY > 6000
				
MULTIPLE CONDITION : 

	INTRODUCE LOGICAL OPERATORS : 
	
		LOGICAL OPERATOR : 
					
						AND  : ALL THE CONDITION MUST BE TRUE 
					CONDITION1 AND CONDITION2 
						IT WILL ONLY RETURN RECORD WHEREN CONDITION1 AND CONDITION2 SATISFIED
						
						OR  : ANY ONE OF THE CONDITION IS TRUE 
						NOT : NEGATION OF THE CONDITION 
						
	
	QUERY : 

		SELECT 
			DEPARTMENT_ID,SALARY,EMPLOYEE_ID 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 80 
							AND 
						SALARY > 6000; 
						
		EXECUTE : 
			* WHERE IS FIRST CLAUSE NEED TO BE EXECUTED 
			* PICK UP FIRST RECORD OF THE TABLE AND CHECK 
				
				FOR(I=0,I++,I=ROWCOUNT)
				{
				IF(DEPARTMENT_ID = 80)
					{
					IF(SALARY > 6000)
						{
							RETUNS TRUE;
						}
					RETRUN FALSE;
					}
				}	
				
				
				
	*****************

		PEOPLE REQIRED ALL EMPLOYEES WITH DEPARTMENT_ID = 20 AND 30 
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 20 AND  DEPARTMENT_ID = 30;
						
			** NO RECORD WILL BE FETCHED 

			
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 20 AND  DEPARTMENT_ID = 30;		
				
			RETUNS ALL THE EMPLOYEES BELONGS TO 20 AND 30 

-------------------------------------------------------------------
	
** NULL - NEED TO TREATED DIFFERNTLY IN THE DATABASE 
	
		NULL - ALWAYS UNIQUE VALUE 
			 - AIRTHMETIC OPERATION WITH ALWAYS RETURN NULL 
			 
			
		LIKE 
			
				2000 + NULL = NULL 
				3000 * NULL = NULL 
				
		DATABASE 
			SELECT 2000 + NULL; 
			
		
		ORACLE : 
				DUAL : ONE ROW ONE COLUMN
				
				SAYS WHEN EVER YOU WANT TO GET CERTAIN DATA WHICH IS NOT RELATED TO TABLE 
					THEN USE DUAL 
					
	HANDLE NULL : 
			INTRODUCE VARIOUS CONCEPT 
				TO SEARCH IN THE TABLLE 

	* FIND THOSE EMPLOYEE GETTING NO COMMISSION 
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						COMMISSION_PCT = NULL;

		COMPARISON WITH NULL - DATABASE INTORDUCE A OPERATOR OR KEYWORD 
							
									IS 
									
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						COMMISSION_PCT IS NULL;


				80000 + (25/100 * 80000)	
					
** 
		RATIONAL OPERATORS 
		LOGICAL OPERATORS 
		AIRTHMETIC OPERATORS 
				:
					(),*,+,-,/
			
			
		EXAMPLE 
			25 HIKE OF THE EMPLOYEE GETTING 80000 SALARY 
			
				
				SELECT	80000 * 1.25 
				
				SELECT ALWAYS EXCUTED ON THE TABLE 
					
					SELECTION IS NOT DEPENDENT ON THE TABLE 
						INTRODUCE 
							DUMMY TABLE 
								DUAL 
								ONE ROW ONE COLUMN 
							
							
				SELECT 80000 * 1.25 FROM DUAL;
				
				SELECT 80000 * 1.25;
				
-------- IN OUR SCENARIO, WE NEED TO FETCH THE DATA FROM THE EXISTING TABLES 

			SYSTEM ALLOWS TO EXECUTE AIRTHMETIC OPERATION ON THE COLUMNS AS WELL 
			
		LIKE :
				
				NEED TO CHECK THE SALARY AND HIKE SALARY BY 25% TO ALL EMPLOYEES.
				
				
			SELECT 
				COLUMN (PERFORM AIRTHMETIC OPERATION) 
					FROM TABLE;
					
			** DATA COMES IN THE TEMP MEMORY
			** PERFORM THE AIRTHMETIC OPERATION 
			** WHAT EVER THE OUTPUT THROWS ON THE CLIENT MACHINE 
			** TEMP MEM RELEASE 
			
			***** WE ARE NOT UPDATING ANYTHING IN THE EXISTING TABLES 
				
		SELECT 
			EMPLOYEE_ID,FIRST_NAME, LAST_NAME,SALARY,
				SALARY * 1.25 
				FROM 
					EMPLOYEES;
					
		** 
			* COLUMNS EMPLOYEE_ID, FIRST_NAME,LAST_NAME,SALARY 
			COMES IN THE TEMP MEMORY 
			* NOW IT CREATES TEMP TABLE BASED ON THE COLUMNS REQUIRED IN THE OUTPUT 
			
		EMPLOYEE_ID FIRST_NAME LAST_NAME SALARY SALARY * 1.25
		102			RAHUL		BANSAL		8000	10000
		
		** NEWLY ITRODUCE COLUMN ONLY FOR MY OUTPUT 
			NOT FOR THE TABLE 
				
				THESE COLUMNS WHICH ARE NEWLY INTRODUCE AND NOT THE PART OF THE TABLE 
					ARE CALLED PSUEDO COLUMNS 
					
------------ 
		FOR MODIFYING THE NAME OF THE COLUMNS BASED ON THE OUTPUT REQUIRED 
			SYSTEM PROVIDED A CONCEPT OF 
				ALIAS
				
				ALIAS : ANOTHER NAME OF THE COLUMNS
				
		SELECT 
			EMPLOYEE_ID EMPNO,FIRST_NAME FIRSTNAME, LAST_NAME LASTNAME,SALARY EMPSAL,
				SALARY * 1.25 HIKESAALRY 
				FROM 
					EMPLOYEES;
				
-----------------
		STANDARDS 
			AS A KEY WORD TO DEFINE ALIAS
			
			SELECT 
			EMPLOYEE_ID AS EMPNO,FIRST_NAME AS FIRSTNAME, LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
				SALARY * 1.25 HIKESAALRY 
				FROM 
					EMPLOYEES;
				
---------------- YOU NEED TO HAVE MORE THEN ONE WORD 

		SELECT 
			EMPLOYEE_ID AS "EMP NO",FIRST_NAME AS "FIRST NAME", LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
				SALARY * 1.25 HIKESAALRY 
				FROM 
					EMPLOYEES;
				
-----------------------------------------------------------------

	NEED TO FIND ALL EMPLOYEES 
		WITH SALARY + COMMISION FROM THE ORGANIZATION 

		SELECT 
			EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
				SALARY AS OLDSALARY,COMMISSION_PCT AS COMM, 
					SALARY + COMMISSION_PCT AS SALCOM
						FROM EMPLOYEES 
							WHERE DEPARTMENT_ID = 20;
			
			
		** HANDLE NULL 
				INTRODUCE THE FUNCTION 
				IFNULL(FIRST PARAMETER, SECOND PARAMETER) 
				
				1ST PARAMETER : COLUMN NAME 
					IF 1ST PARAMETER IS NULL 
						RETURN 2ND PARAMETER VALUE 
					ELSE 
						RETURN 1ST PARAMETER 
					END IF 
					
				IFNULL(COMMISSION_PCT,0);

						COMMISSION_PCT IS NULL 
							RETURN 0 
						ELSE 
							RETUEN COMMISSION_PCT
							
					
		NOW 

			SELECT 
			EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
				SALARY AS OLDSALARY,COMMISSION_PCT AS COMM, 
					SALARY + IFNULL(COMMISSION_PCT,0) AS SALCOM
						FROM EMPLOYEES 
							WHERE DEPARTMENT_ID = 20;
			
			** 
				COLUMNS 
			EMPLOYEE_ID, FIRST_NAME,LAST_NAME,SALARY,COMMISSION_PCT
					COMES IN THE TEMP MEMORY 
					
			2) CREATE NEW TABLE 
		EMPLOYEE_ID, FIRST_NAME,LAST_NAME,SALARY,COMM,SALCOM
			102			RAHUL;	BANSAL		8000 NULL	8000


---------------------------------------------------------

		TREATMENT TO NULL 
			
				* OPERATOR IS 
				* FUNCTION IFNULL 
				
		FIND ALL THE EMPLOYEES WHOSE COMISSION_PCT IS NOT NULL 
		
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE COMMISSION_PCT IS NULL ;
					
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE COMMISSION_PCT IS NOT NULL ;
		
		
		IS NOT : NEGATE THE FETURE OF IS 
		
=============================================================

OPERTORS :- 

			MANY OPERATORS ON THE TOP 
				OF RATIONAL, LOGICAL AND AIRTHMETIC 
				
		
		NEED TO COMPARE WITH MULTIPLE VALUES WITH THE SAME COLUMN  
		
			** NEED ALL EMPLOYEES BELONGS TO 
				DEPARTMENT 20 AND 30 
				
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							DEPARTMENT_ID = 20 
								OR 
									DEPARTMENT_ID = 30;
									
			MULTIPLE VALUE COMPARISON WITH COLUMN 
				THEY INTRODUCE ONE OPERATOR CALLED AS 
						IN
						
			IN :: 
				WHICH COMPARE A SET OF VALUES WITH THE SINGLE COLUMN 
					MAINTANING OR OPERATOR DURING COMPARISON
					
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							DEPARTMENT_ID IN (20,30);
							
			
			** NEED ALL THE EMPLOYEES WHOSE FIRST_NAME 
				IS PAT 
					OR JOHN
					
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							FIRST_NAME IN ('PAT','JOHN');
							
		*****
			MYSQL IS CASE INCENSTIVE 
				MEANS 
					KEYWORDS AND DATA ALSO DURING COMPARION 
						IS CASE INCENSTIVE
							
							
		*****
			PARALLY 
				IN ORACLE 
					KEY WORDS ARE CASE INCENSTIVE 
					DATA IS CASE SENSTIVE
							
		ORACLE QUERY 
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							FIRST_NAME IN ('PAT','JOHN');
							
				Pat , John 
			* empty set 	
							
		** make sure 
			while comparision with string value 
				always remove the case senstivity from the left side and right side of the operator 
			
				PAT = pat
					pat = pat
					PAT  = PAT 
					
			introduce function 
				upper  : used to convert the string in upper case 
				lower  : used to convert the string in lower case 
				
				Select upper('Rahul');
							
		SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							UPPER(FIRST_NAME) in ('PAT','JOHN');					
							
		ALL THE EMPLOYEES 
			WHOSE NAME IS NOT PAT OR JOHN 
			
			
		IN , NOT IN 
			NEGATION OF IN 
			
			
		IS, IS NOT	
							
		SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							UPPER(FIRST_NAME) NOT IN ('PAT','JOHN');					
					
----------------------------------------------------------------------

** 
	COMPARE A COLUMN WITH A VALUE WHICH IS PARTIALLY KNOW 
		
			ONLY AWARE THAT A PARTIAL STRING 
			
		LIKE 
			NEED TO FIND ALL THE EMPLOYEES STARTING WITH A LETTER 
			NEED TO FIND ALL THE EMPLOYEES CONTAINS AS IN THE FIRST NAME 
			NEED TO FIND ALL THE EMPLOYEES WHOSE FIRST NAME ENDING WITH L 
			
			INTRODUCE 
				
					OPERATOR 
						LIKE : SIMILAR TO 
						
						LIKE COMES WITH TWO WILDCARDS 
						
							%  : N NUMBER OF CHARACTERS AND NO CHARACTER
							_  : 1 CHARATERS
							
	** 
		NEED TO FIND ALL THE EMPLOYEES STARTING WITH A LETTER
		
		
		SELECT 
			*
			FROM 
				EMPLOYEES 
					WHERE FIRST_NAME LIKE 'A%';
					
					
	** 
		NEED TO FIND ALL THE EMPLOYEES CONTAINS AS IN THE FIRST NAME 
					
			SELECT 
			*
			FROM 
				EMPLOYEES 
					WHERE FIRST_NAME LIKE '%AS%'		
					
	**
		NEED TO FIND ALL THE EMPLOYEES WHOSE FIRST NAME ENDING WITH L 
		
		SELECT 
			*
			FROM 
				EMPLOYEES 
					WHERE FIRST_NAME LIKE '%L'
					
	** 
		NEED TO FIND ALL THE EMPLOYEES WHOSE FIRST NAME CONTAIND G AT 3 POSITION 
		
		SELECT 
			* 
			 FROM 
				EMPLOYEES 
					WHERE 
						FIRST_NAME LIKE '__G%';
			
									
	** 
		NEED TO FIND ALL THE EMPLOYEES 
			WHOSE FIRST NAME EITHER START FROM A OR J 
			
			BUT CASE IS 
				* PARTIAL VALUES TO SEARCH 
				* MULTIPLE VALUES WITH SAME COLUMN 
				
				LIKE AND IN OPERATOR 
				SYSTEM DOESN'T ALLOW TO HAVE TWO OPERATOR TOGEATHER 
				
		SELECT 
			* 
			 FROM 
				EMPLOYEES 
					WHERE 
						FIRST_NAME LIKE 'A%' 
							OR 
						FIRST_NAME LIKE 'J%'; 
				
-----------------------------------------------------------------				
CHECK CONSTRAINT 
					PUT A RESTRICTION 
						DATE COLUMN SHOULD NOT CONTAIN 
							VALUE 
								(__/__/__)
					
CHECK(HIREDATE LIKE (__/__/__));

--------------------------------------------------------------------------

** 
	DQL 
		SELECT ----------MANDATORY 
			* 
			FROM ----------MANDATORY 
				TABLENAME 
					WHERE ----------NOT MANDAOTRY					
						CONDITION 
							;

-----WHEN WE TALK ABOUT THE STORAGE OF THE DATA IN THE DATABASE 
						IS IN DISTRIBUTED WAY
			SORTING OPERATION ON THE OUTPUT 
			
			
	NEED ALL THE EMPLOYEES SALARY BELONGS TO DEPARTMENT 80 
		AND SORT SALARY IN ASSENDING ORDER 
			ASSENDING 
			 > SMALL TO BIG 
	
	CLAUSE 
		ORDER BY : 
			TWO KEY WORDS 
				ASC  : ASCENDING ORDER
				DESC : DESENDING ORDER
		* BY DEFAULT 
				ITS NATURE IS ASC ORDER 
			
		
		* ALL EMPLOYEES WITH ALL COLUMNS 
		* BELONGS TO DEPARTMENT 80
		* ORDER BY SALARY 
		ASC 
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 80 
							ORDER BY SALARY;
							
		* ORDER BY 
			ORDER BY MUST BE LAST CLAUSE OF THE SELECT QUERY 
			ORDER BY ALLOWS TO USE ALIAS FOR SORTING 
			
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 80 
							ORDER BY SALARY DESC;
							
---------------------------------------------
THERE MAY BE A CASE WHERE I WANT SORTING ON MULTIPLE COLUMN 
								
				* LOGICALLY SORTING ON MULTIPLE COLUMN IN THE SAME OUTPUT IS NOT POSSIBLE 
				
SYSTEM ALLOWS ME TO PUT TWO COLUMN SEPERATED WITH COMMA IN THE ORDER BY CLAUSE 

		SELECT 
			* FROM 
				EMPLOYEES 
					ORDER BY DEPARTMENT_ID,SALARY;
					
		SELECT 
			* FROM 
				EMPLOYEES 
					ORDER BY DEPARTMENT_ID ASC,SALARY DESC;			
					
		SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,30,40) ORDER BY DEPARTMENT_ID DESC,SALARY DESC;			
					
----------------------------------------------------------------------

	(1) SELECT ------MANDATORY 
		* 
		(2) FROM  ------MANDATORY 
			TABLENAME
				(3) WHERE  ------ NOT MANDATORY 
					CONDITION 
						(4) ORDER BY ------ NOT MANDATORY 
							COLUMNS
					
	---------------------------------------------------------------

	FEW ADDITIONAL CONCEPT INTRODUCED 
		* SUPRESS DUPLICATE 
			
			WANT ALL THE DEPARTMENT WHERE EMPLOYEES WORKING 
				FIND ALL THE DEPARTMENT MINIMUM HAS ONE EMPLOYEE 
				
		SELECT DEPARTMENT_ID FROM EMPLOYEES;

			SUPRESS THE DUPLICATE 
					DISTINCT 
		SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES;			

	** 
		SELECT DISTINCT DEPARTMENT_ID, SALARY FROM EMPLOYEES;
		
			* DISTINCT ALWAYS COMES AFTER SELECT AND BEFORE COLUMN NAME 
			* SUPRESS DATA BASED ON THE COLUMN PROVIDED AFTER DISTINCT 
			* COMBINATION OF THE COLUMN BE SUPRESSED 
			
	SIMILARLY 
			LIMIT 
				: A KEYWORD USED TO LIMIT THE OUTPUT 
			
			LIMIT : LIMIT 1 
				MEANS RETURN ONLY SINGLE RECORD
				
				LIMIT 20 
				
			ORACLE HAS SIMILAR FETAURE 
				ROWNUM 
	
EXAMPLE 
		MYSQL 
			
			SELECT * FROM EMPLOYEES LIMIT 10;
				
		ORACLE 
		
			SELECT * FROM EMPLOYEES WHERE ROWNUM < 10;
					OR
			SELECT * FROM EMPLOYEES WHERE ROWNUM = 1;

		MULTI PARAMTER LIMIT 
				
				LIMIT 2,3
					FIRST PARAMETER  : STARTS FROM WHICH ROW 
					SECOND PARAMETER  : COUNT 

					
				SELECT * FROM EMPLOYEES LIMIT 4,4;

------------------------------------------------------------------			