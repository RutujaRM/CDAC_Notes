use sample_db;

/*
Subprograms and Packages
Subprograms (Procedures and Functions)

Practice 1

•	Create a procedure called USER_QUERY_EMP that accepts three parameters. Parameter p_myeno is of IN parameter mode which provides the empno value. The other two parameters p_myjob and p_mysal are of OUT mode. The procedure retrieves the salary and job of an employee with the provided employee number and assigns those to the two OUT parameters respectively. The procedure should handle the error if the empno does not exist in the EMP table by displaying an appropriate message. Use bind variables for the two OUT Parameters.
•	Compile the code, invoke the procedure, and display the salary and job title for employee number 7839. Do the same for employee number 7123.
*/

delimiter $
drop procedure if exists USER_QUERY_EMP$
create procedure USER_QUERY_EMP(in p_myeno int, out p_myjob varchar(20), out p_mysal float)
begin
select job, sal into p_myjob, p_mysal from emp where empno=p_myeno;
end$
delimiter ;
call USER_QUERY_EMP(7499,@X,@Y);
select @X Job,@Y Salary;

/*
Practice 2

•	Create a function named USER_ANNUAL_COMP that has three parameters p_eno, p_sal and p_comm for passing on the values of an employee number, the current salary and commission of the employee respectively. The function calculates and returns the annual compensation of the employee by using the following formula.
     annual_compensation =  (p_sal+p_comm)*12
      If the salary or commission value is NULL then zero should be substituted for it.
*/

delimiter $
drop function if exists USER_ANNUAL_COMP$
create function USER_ANNUAL_COMP(p_eno int,p_sal float,p_comm float) returns float
begin
return (ifnull(p_sal,0)+ifnull(p_comm,0))*12;
end$
delimiter ;
select USER_ANNUAL_COMP(2,null,null);

/*
•	Give a call to USER_ANNUAL_COMP from a SELECT statement, against the EMP table.
*/

delimiter $
drop function if exists USER_ANNUAL_COMP$
create function USER_ANNUAL_COMP(p_eno int) returns float
begin
declare p_comm float;
declare p_sal float;
select sal into p_sal from emp where empno=p_eno;
select comm into p_comm from emp where empno=p_eno;
return (ifnull(p_sal,0)+ifnull(p_comm,0))*12;
end$
delimiter ;
select USER_ANNUAL_COMP(7788);

/*
Practice 3

•	Create a function named USER_VALID_DEPTNO that has a single parameter p_dno to accept a department number and returns a BOOLEAN value. The function returns TRUE if the department number exists in the DEPT table else it returns FALSE.
*/

delimiter $
drop function if exists USER_VALID_DEPTNO$
create function USER_VALID_DEPTNO(p_dno int) returns varchar(5)
begin
	if(p_dno in (select deptno from dept)) 
		then return 'TRUE';
	else return 'FALSE';
	end if;
end$
delimiter ;
select USER_VALID_DEPTNO(50) as Result;

/*
•	Create a procedure named SHOW_STRENGTH that accepts department number in a single parameter p_deptno from user. The procedure gives a call to USER_VALID_DEPTNO. If the function returns TRUE then the procedure finds out how many employees are there in the department from the EMP table and displays the same on the screen. If the function returns FALSE then the procedure displays an appropriate error message.
•	Give call to SHOW_STRENGTH by passing on department number 10. Do the same for department number 76
*/

delimiter $
drop procedure if exists SHOW_STRENGTH$
create procedure SHOW_STRENGTH(in dept_no int)
begin
if USER_VALID_DEPTNO(dept_no)='TRUE'
then select count(*) Strength from emp where deptno=dept_no;
else select 'Enter a valid Department No.' as 'Error';
end if;
end$
delimiter ;
call SHOW_STRENGTH(60);

/*

Practice 4

•	Create a procedure named ADD_EMPLOYEE to hire an employee. Parameters to the procedure are job, mgr, hiredate, salary, commission and deptno. Validate the following:

a. Employee number is not taken as a parameter but is auto generated by using a SEQUENCE. 
b. Job is either ‘CLERK’ or ‘ANALYST’ or ‘SALESMAN’. The input value can be entered in any case (upper or lower or initcap).
c. Mgr is an existing employee.
d. Hiredate is less than system date.
e. Salary must be greater than 800
f. Commission is not null if the job is SALESMAN. For any other job, commission is null.
g. Deptno must exist in the DEPT table.
Insert the record if the above validations are met and display a message ‘1 row inserted’. If the row is not inserted generate an exception and handle it by displaying an appropriate message. 
•	Give a call to ADD_EMPLOYEE through an anonymous PL/SQL block

*/

delimiter $
drop procedure if exists ADD_EMPLOYEE$
create procedure ADD_EMPLOYEE(in ename varchar(10),in job_name varchar(20),in mgr_id int,in hiredate date,in salary float,in commission float,in deptno int)
begin
	if(valid_job(job_name) and valid_mgr(mgr_id) and valid_date(hiredate) and valid_sal(salary) and valid_comm(commission,job_name) and valid_deptno(deptno))
	then insert into emp values(default,ename,job_name,mgr_id,hiredate,salary,commission,deptno,null);
	select '1 row inserted' as Result;
	else SIGNAL sqlstate '45000' set message_text = 'Error inserting new Employee due to incorrect details !';
	end if;
end$
delimiter ;
call ADD_EMPLOYEE('bwooii','salesman',7566,'2020-09-25',80000,null,40);

#-----------JOB Validation-----------

delimiter $
drop function if exists valid_job$
create function valid_job(job_name varchar(20)) returns boolean
begin
 return job_name in ('CLERK','ANALYST','SALESMAN');
end$
delimiter ;

#-----------MGR Validation-----------

delimiter $
drop function if exists valid_mgr$
create function valid_mgr(mgr_id int) returns boolean
begin
 return mgr_id in (select empno from emp);
end$
delimiter ;

#-----------HireDate Validation-----------

delimiter $
drop function if exists valid_date$
create function valid_date(hire_date date) returns boolean
begin
 return hire_date <curdate();
end$
delimiter ;

#-----------Salary Validation-----------

delimiter $
drop function if exists valid_sal$
create function valid_sal(salary float) returns boolean
begin
 return salary>800;
end$
delimiter ;

#-----------Commission Validation-----------

delimiter $
drop function if exists valid_comm$
create function valid_comm(commission float,job_name varchar(20)) returns boolean
begin
 if (job_name='salesman' and commission is not null)
 or 
 (job_name!='salesman' and commission is null) then return true;
 else return false;
 end if;
end$
delimiter ;

#-----------Department Validation-----------

delimiter $
drop function if exists valid_deptno$
create function valid_deptno(p_dno int) returns boolean
begin
	return p_dno in (select deptno from dept);
end$
delimiter ;
 
/*

Practice 5

•	Create a function named FIND_SAL_GRADE which accepts salary of an employee finds the corresponding salary grade from SALGRADE table and returns the grade. The function should raise an exception if the salary value does not fit in any of the salary ranges specified in the salgrade table.

*/

delimiter $
drop function if exists FIND_SAL_GRADE$
create function FIND_SAL_GRADE(salary int) returns varchar(5)
begin
if (select grade from salgrade where salary between losal and hisal) is null
	then signal sqlstate '45000';
else
	return (select grade from salgrade where salary between losal and hisal);
end if;
end$
delimiter ;
select FIND_SAL_GRADE(2000) as Grade;

/*
•	Create a procedure CALL_FIND_SAL_GRADE that does not accept any parameter. The procedure gives call to FIND_SAL_GRADE for each record in the emp table by passing on the salary value from the current record. The procedure displays the corresponding employee number, employee name and the salary grade returned by FIND_SAL_GRADE, on the screen. The procedure should handle error thrown by the function by displaying an appropriate message.
•	Give a call to CALL_FIND_SAL_GRADE through an anonymous PL/SQL block 
*/

delimiter $
drop procedure if exists CALL_FIND_SAL_GRADE$
create procedure CALL_FIND_SAL_GRADE()
begin
declare continue handler for sqlstate '45000' resignal set message_text = 'Salary not in specified range !';
select empno,ename,sal,FIND_SAL_GRADE(sal) from emp;
end$
delimiter ;
call CALL_FIND_SAL_GRADE();

/*

TRIGGERS

Practice 1

•	Implement the following business rule with the help of a trigger named TR_CHECK_DEPT and a procedure named SECURE_DML. Changes to data in the dept table, will be allowed only in the month of March.
•	Create a procedure called SECURE_DML that prevents the DML statement from executing in any other month than March.  In case, a user tries to modify the table in any other month, the procedure should display a message “You can modify or add a department only at the end of a financial year”
•	Create a statement level trigger TR_CHECK_DEPT on the dept table that calls the above procedure.
•	Test it by inserting a new record in the dept table.

*/



/*
Practice 2

•	Enforce referential integrity with a trigger named TR_CASCADE_CHANGE. When the value of DEPTNO changes in the Dept table, cascade the update to the corresponding rows in the EMP table. 
•	Test it by updating the value of a deptno from the dept table.
  
*/

delimiter $
drop trigger if exists TR_CASCADE_CHANGE$
create trigger TR_CASCADE_CHANGE after update on dept for each row
begin
update emp set deptno=new.deptno where deptno=old.deptno;
end$
delimiter ;
update dept set deptno=10 where deptno=50;

/* 
 
Practice 3

•	Create a trigger named TR_CHECK_COMM to implement the following business rule. In EMP table, employee having job as ‘Salesman’ should receive a commission. A Salesman must receive a commission of not less than Rs. 100. Employees who are not sales persons are not entitled to get commission (comm value should be NULL).
•	Test it by inserting a record in the emp table.
*/

delimiter $
drop trigger if exists TR_CHECK_COMM$
create trigger TR_CHECK_COMM before insert on emp for each row
begin
if new.job='salesman' then set new.comm=100;
else set new.comm=null;
end if;
end$
delimiter ;
insert into emp values(default,'bwooii','salesman',7566,'2020-09-25',80000,null,40,null);

/*
Practice 4

•	While modifying the EMP table, ensure that the salary is in the valid range as specified in the SALGRADE table (between lowest  losal and highest  hisal) with the help of a trigger named TR_VALIDATE_SAL.
•	Test it by updating the salary value of an existing record in the emp table.

*/

delimiter $
drop trigger if exists TR_VALIDATE_SAL$
create trigger TR_VALIDATE_SAL before update on emp for each row
begin
if new.sal not between (select min(losal) from salgrade) and (select max(hisal) from salgrade)
then set new.sal=old.sal;
end if;
end$
delimiter ;

/*

Practice5

•	Create a table named salaryLog with the appropriate columns and insert  the empno, new grade, old salary and new salary values in salaryLog table if the grade of an employee changes. 
•	Create a trigger named TR_CHECK_GRADE that will be fired when a user modifies the EMP table. It will check whether the grade has changed by making use of the SALGRADE table. (Grade is dependent on Salary.) If grade is changed, the trigger will log the corresponding employee number, old salary, new salary and new grade into  salaryLog table. 
•	Test the working of the trigger by firing an appropriate DML query.
----

*/

create table salaryLog(empno int, new_grade int, old_salary float,new_salary float);
delimiter $
drop trigger if exists TR_CHECK_GRADE$
create trigger TR_CHECK_GRADE after update on emp for each row
begin
if FIND_SAL_GRADE(old.sal)!=FIND_SAL_GRADE(new.sal)
then insert into salaryLog values(new.empno,FIND_SAL_GRADE(new.sal),old.sal,new.sal);
end if;
end$
delimiter ;
