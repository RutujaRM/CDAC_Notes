						
								DAY 9
				PLSQL - PROGRAMMING LANGUAGE IN MYSQL
========================================================================

				DAY 8 - COVERED AND LERNED VARIOUS TOPIC 
				
					* BLOCK 
						BEGIN
						DECLARE 
						END
					* DBMS - ONLY UNDERSTAND THE ; AS AN TERMINATOR OPERATOR 
					* DELIMITER // 
					* WRITE THE PROCEDURES 
					* CREATE PROCEDRUE 
						ALL SQL COMMANDS 
						DECALRE VARIABLE 
						CONDITION (IF ELSE, CASE)
						USE ALL FUNCTIONS
						LOOP (WHILE , LOOP, NAMED LOOP)
						
					* WORKING WITH SINGLE LINE OF OUTPUT FROM THE SELECT QUERY 
					* NEED TO WORK WITH MULTIPLE ROWS 
						CURSOR
							POINTER 
								THREE STEPS 
									DECLARATIONOF THE CURSOR 
									OPEN CURSOR 
									FETCH THE CURSOR IN TO VARIABLES
									CLOSE THE CURSOR - IS DONE AUTOMATICALLY 
					* WHILE ENCOUNTERING CURSORS 
						WE FACE VARIOUS EXCEPTION ENCOUNTERD WHILE EXECUTING THE PROGRAMS 
							HANDLE TO THOSE EXCEPTION 
								EXCEPTION HANDLER 
						
				EXCEPTION : 
					DECLARE 
					
					DECALRE ACTION HANDLER FOR CONDITION STATEMENTS...
					
					ACTION : 
						EXIT 
						CONTINUE 
					
					CONDITION : 
							NOT FOUND (IN CASE OF CURSORS)
							SQLEXCEPTION
							SQLWARNING
							EXCEPTION NUMBER 
							
----------------------------------------------------------------------

DAC13 : 

		EXAMPLE : 
				HANDLER NOT FOUND FOR CURSOR 
				CONDITION IF AND ELSE 
					SALARY
				FUCNTION CONCAT 
				
				CURSORS : FETCHING THE DATA 
				
	*** 
		NEED A TEMPORARY REPORT OF ALL THE EMPLOYEES WITH THERE DEPARTMENT NAMES BASED ON THE SALARY BRACKET MENTIONE BELOW , MARKED THESE EMPLOYEES WITH GRADES 
		
			SALARY > 15000 THEN A AND INCREMENT THE SALARY WITH 5%
			SALARY BETWEEN 10000 AND 15000 THEN B WITH 10%
			SALARY < 10000 THEN C WITH 15%
			
		EXECUTION OF THE ABOVE QUESTION :- 

			1) NEED TO HAVE A DATA FROM EMPLOYEES AND DEPARTMENT TABLE

			SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, 
				SALARY, DEPARTMENT_NAME 
				FROM EMPLOYEES
				LEFT JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
			
			2) NEED TO HAVE THE VARIABLES WITH ALL THE COLUMNS NEED TO DISLPAY 
				
				DECALRE EMPID INT;
				DECLARE EMPNAME VARCHAR(200);
				DECLARE OLDSAL INT;
				DECLARE NEWSAL INT;
				DECLARE DEPTNAME VARCHAR(50);
				DECLARE V_F INT DEFAULT 0;
				DECLARE GRADES CHAR(2);
				
			
			3) BASED ON THE SALARY COLUMN NEED TO DEFINE THE GRADES 
			
				IF OLDSAL > 15000 THEN 
					SET GRADE = 'A';
					SET NEWSAL = OLDSAL * 1.05;
				ELSEIF OLDSAL > 10000 AND OLDSAL < 15000 THEN 
					SET GRADE = 'B';
					SET NEWSAL = OLDSAL * 1.10;
				ELSE 
					SET GRADE = 'C';
					SET NEWSAL = OLDSAL * 1.15;
				END IF;
			
			4) CREATE A TEMPORARY TABLE TO PUSH THE DATA 
				
				CREATE TEMPORARY TABLE EMPREPORT
				(
				ID INT;
				NAME VARHCAR(100);
				OLDSALARY INT;
				NEWSALARY INT;
				DEPTNAME VARHCAR(50);
				GRADE CHAR(2)
				);
			
			5) HANDLE THE EXCEPTION WHICH EVER ENCOUNTER 
			
				DECALRE CONTINUE HANDLER FOR NOT FOUND SET V_F = 1;
			
			6) PRESENT THE DATA BASED ON THE SALARY BRACKET 
			
				INSERT INTO EMPREPORT VALUES(EMPID,EMPNAME,OLDSAL,NEWSAL,DEPTNAME,GRADES);
				
				SELECT * FROM EMPREPORT;
				
				DROP TABLE EMPREPORT;
				
-------------------------------------------------------------------

				DELIMITER // 

				DROP PROCEDURE IF EXISTS DAC13 //

				CREATE PROCEDURE DAC13()
				BEGIN 
				DECLARE EMPID INT;
				DECLARE EMPNAME VARCHAR(200);
				DECLARE OLDSAL INT;
				DECLARE NEWSAL INT;
				DECLARE DEPTNAME VARCHAR(50);
				DECLARE V_F INT DEFAULT 0;
				DECLARE GRADES CHAR(2);
				DECLARE EMP_CUR1 CURSOR 
					FOR SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, 
						SALARY, DEPARTMENT_NAME 
							FROM EMPLOYEES
								LEFT JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
				DECLARE CONTINUE HANDLER FOR NOT FOUND SET V_F = 1;

				CREATE TEMPORARY TABLE EMPREPORT
				(
				ID INT,
				NAME VARCHAR(100),
				OLDSALARY INT,
				NEWSALARY INT,
				DEPTNAME VARCHAR(50),
				GRADE CHAR(2)
				);
				
				OPEN EMP_CUR1;

				L_LEVEL : LOOP
				
					FETCH EMP_CUR1 INTO EMPID,EMPNAME,OLDSAL,DEPTNAME;
					
					IF V_F = 1 THEN 
						LEAVE L_LEVEL; -- BREAK POINT 
					END IF;
					
					IF OLDSAL > 15000 THEN 
						SET GRADES = 'A';
						SET NEWSAL = OLDSAL * 1.05;
					ELSEIF OLDSAL > 10000 AND OLDSAL < 15000 THEN 
						SET GRADES = 'B';
						SET NEWSAL = OLDSAL * 1.10;
					ELSE 
						SET GRADES = 'C';
						SET NEWSAL = OLDSAL * 1.15;
					END IF;
					
			
				INSERT INTO EMPREPORT VALUES(EMPID,EMPNAME,OLDSAL,NEWSAL,DEPTNAME,GRADES);
				
				END LOOP L_LEVEL;
				
				CLOSE EMP_CUR1;
				
				SELECT * FROM EMPREPORT;
				
				DROP TABLE EMPREPORT;
				
				END //
				
				DELIMITER ;
			
======================================================================

HANDLING THE EXCEPTION : 

			** NOT FOUND - THIS COMES ONLY IN CASE OF CURSORS 
			
PROCEDURE WHICH ACCEPT TWO VALUES AND STORE INTO THE TABLE 
	WHICH WAS ALREADY DEFIN WITH PRIMARY KEY 
	
			CREATE TABLE EMPSTANDARD
			(
			EMPID INT PRIMARY KEY,
			EMPSALARY INT,
			ADDEDDATE DATE,
			ADDEDBY VARCHAR(50)
			);
			
			
		DELIMITER // 
			
		CREATE PROCEDURE DAC14(ID INT, SAL INT)
		BEGIN
		INSERT INTO EMPSTANDARD VALUES(ID,SAL,CURDATE(),USER());
		END //
		DELIMITER ;
		
		
		CREATE TABLE EMPSTANDARD_ERROR
		(
		ID INT AUTO_INCREMENT PRIMARY KEY,
		DESCRIPTION VARCHAR(200),
		ADDEDDATE DATETIME,
		ADDEDBY VARCHAR(50),
		EVENT VARCHAR(200)
		);
		
			
			
		DELIMITER // 
			
		DROP PROCEDURE IF EXISTS DAC14 //
		
		CREATE PROCEDURE DAC14(ID INT, SAL INT)
		BEGIN
		
		DECLARE EXIT HANDLER FOR 1062 
				BEGIN
					INSERT INTO EMPSTANDARD_ERROR(DESCRIPTION,ADDEDDATE,ADDEDBY,EVENT) VALUES('DUPLICATE DATA ENTRY',NOW(),USER(),'INSERT');
					SELECT * FROM EMPSTANDARD_ERROR ORDER BY ID DESC LIMIT 1;							
				END;		
		INSERT INTO EMPSTANDARD VALUES(ID,SAL,CURDATE(),USER());
		END //
		DELIMITER ;	
			
=====================================================================

SMALLER EXAMPLE : 

		WRITE A PROCEDURE WHICH DISPLAY EMPLOYEES DATA OF THE PERTICULAR DEPARTMENT 
		
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC15 //
		
		CREATE PROCEDURE DAC15(DEPTID INT)
		BEGIN 
		DECLARE ID INT;
		DECLARE NAME VARCHAR(200);
		DECLARE SALARY INT;
		DECLARE V_FINISH INT DEFAULT 0;
		DECLARE EMP_CUR2 CURSOR
			FOR SELECT EMPLOYEE_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = DEPTID;
		DECLARE CONTINUE HANDLER FOR SQLEXCEPTION 
								BEGIN
								SET V_FINISH = 1;
								SELECT 'SQLEXCEPTION' NAME;
								END;
		DECLARE CONTINUE HANDLER FOR NOT FOUND 
								BEGIN
								SET V_FINISH = 1;
								SELECT 'DATA NOT FOUND' NAME;
								END;		
		CREATE TEMPORARY TABLE TEMP_EMP(EMPID INT,EMPNAME VARCHAR(200),SAL INT);
		
		OPEN EMP_CUR2;
		
		L_RAHUL : LOOP 
			
				FETCH EMP_CUR2 INTO ID,NAME,SALARY;
				
				IF V_FINISH = 1 THEN 
					LEAVE L_RAHUL;
				END IF ;
				
				INSERT INTO TEMP_EMP VALUES(ID,NAME,SALARY);
				
		END LOOP L_RAHUL;
		
		CLOSE EMP_CUR2;
		
		SELECT * FROM TEMP_EMP;
		
		SELECT RAHUL;
		
		DROP TABLE TEMP_EMP;
		
		END //
		
		DELIMITER ;
			
======================================================================

THIS ALL ABOUT PROCEDURES 
				
					HANDLING WITH 
						VARIABLES
						CURSORS
						EXCEPTION HANDLING 
						BEGIN END 
						LOOPS 
						CONDITIONS 
						
SAME CODING STANDARDS CAN BE USED INSIDE THE FUNCTIONS AS WELL ....

FUNCTIONS : 
			DECLRATION OF THE VARIABLE 
			CURSORS
			HANDLERS 
			CONDITION 
			LOOP 
			IN / OUT / INOUT VARIABLE 
			
			ALL WILL BE USED HERE AS WELL 
			
			** FUNCTIONS ARE DESIGNED TO RETURN THE VALUES ..... 
			
		
		SYNTAX : 
			
				CREATE FUNCTION FUNCTIONNAME()
						RETURNS DATATYPE
				BEGIN 
				
				RETURN VALUE....
			
				END;
				
				
				
		SMALL PROGRAM :
				RETURN ME THE SUM OF TWO VALUES 
				
				VAR1 AND VAR 2
					VAR1 + VAR2 
					
			DELIMITER //
			
			CREATE FUNCTION DAC16(X INT, Y INT)
					RETURNS INT 
			BEGIN 
				
				RETURN X + Y;
			
			END //
			
			DELIMITER ;
				
			SET GLOBAL log_bin_trust_function_creators = ON;	
				
			 CALLING FUNCTION : 
			 
			 SELECT DAC16(10,20);
		
----------------------------------------------------------------

DAC17 : SPELL OUT OF DAY OF THE DATE 

			1 TO 31 
				SPELL THOSE NUMBER 
					
					9 : NINE 
					21 : TWENTY ONE 
					
					30 : THIRTY 
					
					
		0 - 10 , 11- 19, 20, 21 - 29, 30, 31 
		
		SUBSTR : 
			SUBSTR(STRING,POSITION,LENGTH)
		
		0 - 10 
		
		'ZERO ONE  TWO  THREEFOUR FIVE SIX  SEVENEIGHTNINE TEN  '
		LENGHT = 5
		
		FIVE : 
		
			SUNSTR(STR,5*5,5) = FIVE 
			SUBSTR(STR,1*5,5) = ONE
		
		11 - 19 
		
		'ELEVEN   TWELVE   THIRTEEN FOURTEEN FIFTEEN  SIXTEEN  SEVENTEENEIGHTEEN NINETEEN '
		LENGHT = 9
		

		START WITH THE PROGRAM: 
		
			DELIMITER //
			
			DROP FUNCTION IF EXISTS DAC18 //
			
			CREATE FUNCTION DAC18(X INT)
					RETURNS VARCHAR(200)
			BEGIN 

			DECLARE STR1,STR2,STR3,SPELLSTR VARCHAR(500);
			
			IF X < 11 AND X >= 0 THEN 
			
			SET STR1 = 'ZERO ONE  TWO  THREEFOUR FIVE SIX  SEVENEIGHTNINE TEN  ';
			
			SET SPELLSTR = TRIM(SUBSTR(STR1,(X * 5) + 1,5));
			
			ELSEIF X < 20 THEN 
			
			SET STR2 = 'ELEVEN   TWELVE   THIRTEEN FOURTEEN FIFTEEN  SIXTEEN  SEVENTEENEIGHTEEN NINETEEN ';
			
			SET SPELLSTR = TRIM(SUBSTR(STR2,(X - 11) * 9 + 1,9));
			
			ELSEIF X = 20 THEN 
			
			SET SPELLSTR = 'TWENTY';
			
			ELSEIF X < 30 THEN 
			
				SELECT DAC18(X%10) INTO STR3;
				
				SET SPELLSTR = CONCAT('TWENTY ',STR3);
				
			ELSEIF X = 30 THEN 
			
				SET SPELLSTR = 'THIRTY';
				
			ELSEIF X = 31 THEN 
			
				SET SPELLSTR = 'THIRTY ONE';
				
			ELSE 
			
				SET SPELLSTR = 'NOT A DAY, INCORRECT NUMBER';
				
			END IF;
			
			RETURN SPELLSTR;
			
			END //
			
			DELIMITER ;
			
	*************************************************************

mysql> SELECT DAC18(25);
ERROR 1424 (HY000): Recursive stored functions and triggers are not allowed.

	SYSTEM DOESNT MENTIONED ABOUT THE PROCEDURE 
	
	LETS CONVERT THIS COMPLETE FUNCTION IN THE STORE PROCEDURE
	---------------------------------------------------------
	
			DELIMITER //
			
			DROP PROCEDURE IF EXISTS DAC19 //
			
			CREATE PROCEDURE DAC19(X INT,OUT TEMPSTR VARCHAR(200))
			BEGIN 

			DECLARE STR1,STR2,STR3,SPELLSTR VARCHAR(500);
			
			IF X < 11 AND X >= 0 THEN 
			
			SET STR1 = 'ZERO ONE  TWO  THREEFOUR FIVE SIX  SEVENEIGHTNINE TEN  ';
			
			SET TEMPSTR = TRIM(SUBSTR(STR1,(X * 5) + 1,5));
			
			ELSEIF X < 20 THEN 
			
			SET STR2 = 'ELEVEN   TWELVE   THIRTEEN FOURTEEN FIFTEEN  SIXTEEN  SEVENTEENEIGHTEEN NINETEEN ';
			
			SET TEMPSTR = TRIM(SUBSTR(STR2,(X - 11) * 9 + 1,9));
			
			ELSEIF X = 20 THEN 
			
			SET TEMPSTR = 'TWENTY';
			
			ELSEIF X < 30 THEN 
			
				CALL DAC19(X%10,STR3);
				
				SET TEMPSTR = CONCAT('TWENTY ',STR3);
				
			ELSEIF X = 30 THEN 
			
				SET TEMPSTR = 'THIRTY';
				
			ELSEIF X = 31 THEN 
			
				SET TEMPSTR = 'THIRTY ONE';
				
			ELSE 
			
				SET TEMPSTR = 'NOT A DAY, INCORRECT NUMBER';
				
			END IF;
			
			END //
			
			DELIMITER ;			
					
mysql> CALL DAC19(23,@TEM);
ERROR 1456 (HY000): Recursive limit 0 (as set by the max_sp_recursion_depth variable) was exceeded for routine DAC19
mysql>
					
------------------------------

TO USE ABOVE PROCEDURE INSIDE THE SELECT ---------

						CALL THE PROCEDURE FROM THE FUNCTION 
						
				
		FUNCTION WHICH CALL OUR PROCEDURE 
		
		DELIMITER //
		
		DROP FUNCTION IF EXISTS DACSPELLFUN //
		
		CREATE FUNCTION DACSPELLFUN(X INT)
				RETURNS VARCHAR(500)
		BEGIN 
			
			DECLARE SPELL VARCHAR(500);
			
			CALL DAC19(X,SPELL);
			
			RETURN SPELL;
			
		END //
		
		DELIMITER ;
		
	
	IMPORTANT : 		
	SELECT DAY(HIRE_DATE),DACSPELLFUN(DAY(HIRE_DATE)) SPELLOUT FROM EMPLOYEES LIMIT 10;	
		
				
				
	HANDLE THE VALUES GREATER THEN 31 
					CONDITION 
				
=====================================================================

			
				
							
							
							
							
							
							
						
						
						
						
						
						
						
						
						
						
				
		