		
								DAY 7
								
TOPICS COVERED: 
					
		TYPES OF JOIN :
				INNER 
				OUTER
				NATURAL
				SELF
				CROSS
				
				EQUIJOIN/NON EQUIJOIN 
				
	BASICALLY THESE ARE USED FOR GETTING DATA FROM DIFFERENT TABLES
	
	----------------------------------------------------------------
	
	NEED TO FIND THE EMPLOYEES WHOSE SALARY ID GREATER THEN THE SALARY OF THE AVERAGE SALARY OF DEPARTMENT 80 
	
		1) AVERAGE SALARY OF THE DEPARTMENT 80 
		
		SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80;
					80000
		2) FIND ALL THE EMPLOYEES WHOSE SALARY > SALARY RETURNED FROM STPE 1 
		
		SELECT * FROM EMPLOYEES WHERE SALARY > 80000;
		
		
	SUBQUERY : 
			IS A QUERY WHICH ENBADDED INSIDE THE OTHER QUERY 
			
			RULES : 
				1) SUBQUERY EXECUTED FIRST
				2) OUTPUT OF THE SUBQUERY REPLACED INLINE 
				3) MAIN QUERY EXECUTED
				
			** FEW THINGS 
					IF SUBQUERY RETURNS MORE THE ONE ROW 
						THEN WE CAN NOT COMPARE THOSE VALUES WITH THE HELP OF EQUALS TO OPERATOR 
					IN THIS SCENARIO WE ALWAYS USE IN OPERATOR 
					---- 
					
					IF WE ARE SURE THAT SUBQUERY WILL RETURN A SINGLE VALUE THEN WITHOUT ANY CONCERNS, WE CAN USE EQUALS OPERATOR.
					
			SELECT 
				COLUMN    ------ SUB QUERY 
					FROM 
						TABLES   ------ SUB QUERY 
							WHERE 
								CONDITION ------ SUB QUERY 
									GROUP BY 
										COLUMNS 
											HAVING 
												COLUMNS 
													ORDER BY 
														COLUMNS
															LIMIT 
				
					
	CONSIDERING A FACT OF SUBQUERY 
		WE ALWAYS USE OR ENTER SUBQUERY INSIDE THE BRACKETS 
			AS SUBQUERY NEED TO RETUN THE VALUES 
			
			**
					
		NEED TO FIND THE EMPLOYEES WHOSE SALARY ID GREATER THEN THE SALARY OF THE AVERAGE SALARY OF DEPARTMENT 80 
	
		1) AVERAGE SALARY OF THE DEPARTMENT 80 
		
		SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80;
					80000
		2) FIND ALL THE EMPLOYEES WHOSE SALARY > SALARY RETURNED FROM STPE 1 
		
		SELECT * FROM EMPLOYEES WHERE SALARY > 80000;			
					
		MERGE ABOVE QUERIES :- 

		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80);
					
			** SUBQUERY EXECUTED FIRST AND REPLACE THE QUERY WITH THE VALUE RETURNED FROM THE SUB QUERY 
	
			STEPS 1: 
			
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							SALARY > (8955.882353);
							
			STEP 2: 
				MAIN QUERY EXECUTED WITH THE INLINE VALUE 
				RETURNS ME THE EMPLOYEES DATA..
				
				
		** NO RESTRICTION OF HAVING HOW MANY SUB QUERIES 

			LIKE 
		NEED ALL THE EMPLOYEES 
			HAVING SALARY > AVG SALARY OF DEPARTMENT 80 
				AND BELONGS TO THE DEPARTMENTS IN LOCATION 1700 
				
		* NEED TO FIND AVG SALARY OF DEPARMTNET 80 
		
			SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80
		
		* NEED TO FIND ALL DEPARTMENT WORKING IN LOCATION 1700 
		
			SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = 1700
		
		* FIND ALL EMPLOYEES BASED ON 1, 2	
			
				
			
			SELECT * FROM 
				EMPLOYEES E1 
				INNER JOIN 
				DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
				WHERE 
				E1.SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80)
				AND 
				D1.DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = 1700);
					
--------------------------------------------------------------

THERE MAY BE SCENARIO WHERE I NEED TO COMPARE WITH OPERATORS LIKE > ,  <  WITH MULTIPLE VALUE 

		NEED TO FIND ALL EMPLOYEES WHOSE SALARY 
			IS GREATER THEN THE SALARY OF DEPARTMENT 60
			
			* NEED TO FIND THE SALARY PROVIDED TO DEPARTMENT 60 
			
				SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60;
					MULTIPLE VALUES RETURNED 
			
			* COMPARE THE EMPLOYEES SALARY TO VALUES RETURN FROM 1 STPE 
			
			SELECT * FROM EMPLOYEES 
				WHERE 
					SALARY > (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60);
			
			EXECUTION HAPPEN: 
				
			SELECT * FROM EMPLOYEES 
				WHERE 
					SALARY > (9000,6000,4800,4200);
				
				
				
			*** 
				VARIOUS COMBINATION OPERATORS TO ACHIVE ABOVE COMPARISON 
				
				ANY / ALL 
				
				ANY : ANY ONE VALUE NEED TO BE SATISFIED 
				ALL : ALL THE VALUES NEED TO BE SATISFIED 
				
				* RULES 
					ANY AND ALL CAN BE USED IN THE COMBINATION OF OTHER OPERATORS LIKE 
						>, < , = 
				COBINATION OF ABOVE OPERATORS 

					> ANY -- IF THERE ARE MULTIPLE VALUES RETURNED FROM THE SUBQUERY THEN 
						COMPARISON WITH ANY VALUE IF TRUE THEN IT 
							RETURS THE ROW FROM THE MAIN QUERY 
							
							
					> ALL -- ALL NEED TO COMPARED AND SATISFIED 
						3000 > ALL (2000, 1000, 500, 5000) 
							- 3000 WILL NOT BE RETURNS AS 
								3000 > 5000
						3000 > ALL (2000, 1000, 500)
							IT RETUNS TRUE 
						
					< ANY 
					< ALL 
					= ANY
		
NEED TO FIND ALL EMPLOYEES WHOSE SALARY 
			IS GREATER THEN THE SALARY OF DEPARTMENT 60
			
		SELECT MIN(SALARY) FROM EMPLOYEES 
				WHERE 
					SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60);			
						
		EXECUTION: 
			STEP 1: 
				SELECT * FROM EMPLOYEES 
				WHERE 
					SALARY > ALL (9000,6000,4800,4200);	
					
			RAHUL 24000

				24000 > ALL (9000,6000,4800,4200);
						
						
NEED TO FIND ALL EMPLOYEES WHOSE SALARY 
			IS GREATER THEN ANY OF THE SALARY OF DEPARTMENT 60
			
		SELECT MIN(SALARY) FROM EMPLOYEES 
				WHERE 
					SALARY > ANY (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60);						
						
						
-----------------------------------------------------------------------

					IN / ANY / ALL 
					
	SELECT S1 FROM T1 WHERE S1 >ANY (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 = ANY (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 IN (TABLE S2);			
	SELECT S1 FROM T1 WHERE S1 > ALL (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 < ALL (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 <> ALL (TABLE S2);
	
	<> NOT EQUALS TO 
	
					SUBQUERY AS A PART OF WHERE CLAUSE 
					
------------------------------------------------------------------------
------------------------------------------------------------------------

2) SUB QUERY CAN BE A PART OF TABLE 
	
		SUBQUERIES 
			: THEY ALWAYS RETURN A TABLE AS AN OUTPUT 
				WITH ROWS AND COLUMN 
				
			* SUBQUERY NEED TO BE INCLUDED IN THE BRACKET 
			* WHEN SUBQUERY IS A PART OF TABLE 
				SYSTEM FORCE US TO NAME THAT TABLE 
				
		CONSIDERING AN EXAMPLE 
			
		NEED TO FIND ALL EMPLOYEES 
			WITH THE DEPARTMENT NAMES AND LOCATIONS 
				CONSIDERING THERE SALARY > MINIMUM SALARY OF DEPARTMENT 
					80 
					
					
		* FIND THE DETAILS OF EMPLOYEES 
			FROM EMPLOYEES , DEPARTMENTS AND LOCATIONS 
			
			SELECT 
				E1.EMPLOYEE_ID, CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME, E1.SALARY , D1.DEPARTMENT_NAME,
					L1.STREET_ADDRESS
				FROM 
					EMPLOYEES E1 
					INNER JOIN 
					DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					INNER JOIN 
					LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID;
					
		----------- I AM TREATING ABOVE QUERY AS A SUBQUERY 

	SELECT * FROM 
			(SELECT 
				E1.EMPLOYEE_ID, CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME, E1.SALARY , D1.DEPARTMENT_NAME,
					L1.STREET_ADDRESS
				FROM 
					EMPLOYEES E1 
					INNER JOIN 
					DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					INNER JOIN 
					LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID) T
			WHERE T.SALARY > 
			(SELECT MIN(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80);
				
-----------------------------------------------------------------------

ABOVE QUERY - SUBQUERY IS A PART OF TABLE 
		BASED ALL PREVIOUS LOGICS WE CAN ALSO JOIN OTHER TABLES 
			WITH THE SUBQUERY TREATED A TABLE 
			
	
SELECT SALARY FROM (	
SELECT T.EMPLOYEE_ID,T.NAME,T.SALARY,T.DEPARTMENT_NAME,C1.COUNTRY_NAME 	
			FROM 
			(SELECT 
				E1.EMPLOYEE_ID, CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME, E1.SALARY , D1.DEPARTMENT_NAME,
					L1.STREET_ADDRESS,L1.COUNTRY_ID
				FROM 
					EMPLOYEES E1 
					INNER JOIN 
					DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					INNER JOIN 
					LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID) T
			INNER JOIN 
			COUNTRIES C1 ON T.COUNTRY_ID = C1.COUNTRY_ID
			) TY 
			LIMIT 10;
			
		*** 
			NEVER EVER TRY TO WRITE QUERY DIRECTLY ...
			* FIRST ANALYSE QUESTION 
			* BREAK INTO SUB PARTS 
			* WRITE THE QUERIES FOR THE SUB PART 
			* MERGE THEM TO GEATHER 
			
---------------------------------------------------------------------

SUBQUERY USED AT THE PLACE OF COLUMNS 
	
		:	
		* SUBQUERY NEED TO BE IN BRACKETS 
		* IN THIS CASE
			MAIN QUERY EXECUTED FIRST AND THEN 
				FOR EVERY VALUE 
					SUB QUERY EXECUTED 
					
**** 
		NEED TO FIND EMPLOYEES AND THERE DEPARTMENT NAME 
			WITHOUT JOIN OPERATIONS 
			
				* GET ALL THE EMPLOYEES FROM EMPLOYEE TABLE 
				
				
				SELECT 
					EMPLOYEE_ID,FIRST_NAME,LAST_NAME,SALARY, 
					DEPARTMENT_ID 
					FROM 
						EMPLOYEES;
				
				* FOR EVERY EMPLOYEE I HAVE REPLACE THE DEPARTMENT ID WITH THE NAME AFTER DOING COMPARISION WITH DEPARTMNET TABLE 
				
				
				SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 WHERE D1.DEPARTMENT_ID = 
					
		MERGE ABOVE QUERIES : 

			SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,SALARY, 
					(SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 	
							WHERE 
							D1.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS DEPTNAME 
					FROM 
						EMPLOYEES E1;

			** OUTER QUERY EXECUTED FIRST 
				IT RETURN FIRST ROW FROM EMPLOYEE TABLE 
				101 RAHUL BANSAL 800000 80 
				
			STEP 2**
			SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,SALARY, 
					(SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 	
							WHERE 
							D1.DEPARTMENT_ID = 80) 
					FROM 
						EMPLOYEES E1;	
					
			STEP3 :
				101 RAHUL BANSAL 800000 Sales
					
					
					




SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,SALARY, 
					(SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 	
							WHERE 
							D1.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS DEPTNAME 
					FROM 
						EMPLOYEES E1;
						
		* OUTER QUERY EXECUTED FIRST 
			* FOR EVERY ROW THE INNER QUERY EXECUTED ....
			
			
********* THESE TYPE OF QUERIES ALSO CALLED AS CORRELATED QUERIES 

	*** 
		NEED TO FIND ALL THE EMPLOYEES 
			WHOSE SALARY IS GREATED THEN AVERAGE SALARY OF IT'S DEPARTMENT 
				
		* 
			1) NEED TO FIND THE DEPARTMENT OF EACH ROW 
			2) FOR THAT DEPARTMENT - NEED TO CALCULATE AVERAGE SALARY 
			3) EMPLOYEES RETURNED FROM 1 , ITS SALARY NEED TO BE COMPARED WITH STEPS 2 SALARY 
			



			1) NEED TO FIND THE DEPARTMENT OF EACH ROW 
				
				SELECT * FROM 
					EMPLOYEES E1
						WHERE E1.SALARY > 
							??
			
			2) FOR THAT DEPARTMENT - NEED TO CALCULATE AVERAGE SALARY 
			
			
				SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 WHERE 
					E2.DEPARTMENT_ID = ??
			
			3) EMPLOYEES RETURNED FROM 1 , ITS SALARY NEED TO BE COMPARED WITH STEPS 2 SALARY 
					
		MERGE THE STEPS 1, 2
		
			SELECT * FROM 
					EMPLOYEES E1
						WHERE E1.SALARY > 
							(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
								WHERE 
								E2.DEPARTMENT_ID = E1.DEPARTMENT_ID);
								
			101 RAHUL 9000 20 ---
			102 RITESH 8000 20 
			103 NIKHIL 2000 20 
	1) PICKED FIRST ROW 
	
		101 RAHUL 9000 20 	
		SELECT * FROM 
					EMPLOYEES E1
						WHERE E1.SALARY > 
							(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
								WHERE 
								E2.DEPARTMENT_ID = 20);
			
	2) FIND AVERAGE SALARY OF DEPARTMENT 20 

		101 RAHUL 9000 20 	
		SELECT * FROM 
					EMPLOYEES E1
						WHERE 9000 > 
							(6333);
	
	
	3) COMPARISION 
			IF TRUE ROW RETURN TO THE OUTPUT 
			101 RAHUL 9000 20
				
	-----------
	NEED TO CHECK/VALIDATE 
	

SELECT EMPLOYEE_ID,SALARY,AVERAGESALARY,CASE WHEN SALARY > AVERAGESALARY THEN 'TRUE' ELSE 'FALSE' END AS STATUS
FROM 
(	
SELECT E1.EMPLOYEE_ID,E1.SALARY,
		(SELECT AVG(E3.SALARY) 
			FROM EMPLOYEES E3 
				WHERE 
					E3.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS AVERAGESALARY 
			FROM 
			EMPLOYEES E1
			WHERE E1.SALARY > 
				(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
					WHERE 
					E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
) T;
	
--------------------------------------------------------------	

SUBQUERY : 
		USED IN WHERE CLAUSE 
			USED AT TABLE PLACE 
				USED AT COLUMN LEVEL - CORRELATED QUERIES 
											WHERE 2 QUERIES ARE DEPENDED ON EACH OTHER 
											

SUBQUERY CAN ALSO BE A PART OF YOUR INSERT AND CREATE COMMANDS 

	LIKE : 
			WE NEED TO CREATE A TABLE WITH SAME STRUCTURE OF SOME EXISTING TABLE 
			
			SYNTAX : 
					CREATE TABLE EMPLOYEES_NEW LIKE EMPLOYEES;

		** NEED TO CREATE A TABLE WITH STRUCTURE AND DATA TO BE COPIED 
		
			TWO WAYS TO DO IT 
				1) 	CREATE TABLE EMPLOYEES_NEW LIKE EMPLOYEES;
					INSERT ROWS 
					
	SYNTAX FOR INSERT + SUBQUERY : 
	
		INSERT INTO EMPLOYEES_NEW SELECT * FROM EMPLOYEES;

				2) CREATE + SUBQUERY TOGEATHER
						*
						* CREATE TABLE WITH THE HELP OF SELECT QUERY 
							CONSTRINTS DOESN'T COPY AS THIS IS TABLE CREATED FROM SELECT 
							
					CREATE TABLE EMPLOYEE_CREATETABLE 
						AS 
							SELECT * FROM EMPLOYEES;
							
					* 1 CREATE TABLE 
					* 2 INSERT DATA 
					
							
	INSERT INTO EMPTEMP SELECT EMPLOYEE_ID,CONCAT(FIRST_NAME,LAST_NAME) NAME, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 80 AND SALARY > 2000;						
							
	CONCEPT OF TEMPRORARY TABLES 
			* 
				* THESE TABLE ARE A PART OF YOUR SESSION 
				* 	WE CAN USE THESE TABLE DURING A TRANSACTION 
				*		THESE TABLE AUTOMATICALLY WIPES AS YOUR TRANATION OVER OF YOUR SESSION OVER....
						
	SYNTAX : 
			CREATE TEMPORARY TABLE EMP_TEMP AS SELECT * FROM EMPLOYEES;
							
----------------------------------------------------------------------

--- MOST OF THE TIME QUERIES WHICH ARE COMMANLY USED ARE WRITTEN ONCE AND USED MULTIPLE TIME 
								
		OR 
		
		METHODS WHICH ARE COMMANLY USED 
			LIKE CALCULATING HIKE SALARY BASED ON PERCENTAGE 
				METHOD 
					USED THEM WHEN EVER REQUIRED 
					
		* THIS CAN ALSO BE ACHIVED IN THE DATA BASE 
			WITH THE HELP OF VIEWS CONCEPT 
			
		VIEWS :
				1) VIEWS ARE USED TO ENCAPSULATE THE DATA
				2) VIEWS ARE USED TO STORE THE SYNTAX OF THE QUERY IN THE DATABASE ITSELF 
				3) VIEWS NEVER EVER CREATE ANOTHER TABLE IN THE DATABASE 
				
		** A DEFINCATION STORED IN THE DATABASE 
			USER CAN CALL THEM WHEN EVER REQUIRED.....
			
		SYNTAX : 

			CREATE VIEW VIEWNAME AS SELECT QUERY.....
			
			TYPE OF VIEWS 
				SIMPLE
					SIMLE MEANS : VIEWS CREATED WITH SINGLE TABLE 
					
				COMPLEX 
					VIEWS ARE CREATED WITH MULTIPLE TABLE 
					
			
CREATE VIEW EMPAVERAGESALARY_VIEW 
AS			
SELECT EMPLOYEE_ID,SALARY,AVERAGESALARY,CASE WHEN SALARY > AVERAGESALARY THEN 'TRUE' ELSE 'FALSE' END AS STATUS
FROM 
(	
SELECT E1.EMPLOYEE_ID,E1.SALARY,
		(SELECT AVG(E3.SALARY) 
			FROM EMPLOYEES E3 
				WHERE 
					E3.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS AVERAGESALARY 
			FROM 
			EMPLOYEES E1
			WHERE E1.SALARY > 
				(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
					WHERE 
					E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
) T;
			
			
	* CREATE A VIEW WITH EMPAVERAGESALARY_VIEW
	* CAN BE CALLED AS SIMPLE AS CALLING ANOTHER TABLE
	
	
		SELECT * FROM EMPAVERAGESALARY_VIEW
			EXECUTION OF THIS :
			
			SELECT * FROM 
			(SELECT EMPLOYEE_ID,SALARY,AVERAGESALARY,CASE WHEN SALARY > AVERAGESALARY THEN 'TRUE' ELSE 'FALSE' END AS STATUS
			FROM 
			(	
			SELECT E1.EMPLOYEE_ID,E1.SALARY,
					(SELECT AVG(E3.SALARY) 
						FROM EMPLOYEES E3 
							WHERE 
								E3.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS AVERAGESALARY 
						FROM 
						EMPLOYEES E1
						WHERE E1.SALARY > 
							(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
								WHERE 
								E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
			) T) Y
			
		VIEW WHICH IS CREATED BY THE USER - IS COMPLETLY A PART OF THE DATABASE 
			
			
			** FLEXIBLITIES PROVIDED BY THE DATABASE ON THE VIEWS 
			
				ENCAPSULATE : 
				
				
			CREATE VIEW EMPLOYEES_VIEW1 
			AS
			SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,JOB_ID,DEPARTMENT_ID 
				FROM 
					EMPLOYEES;
			
			***
				ADDITIONAL FUNCTIONALITIES 
					TALKING NOT TO PROVIDE THE PERMISSION ON MAIN TABLE 
						JUST PROVIDE ACCESS ON THE VIEWS 
						
					
				** INSERT , UPDATE, DELETE PERMISSION  
				
			VIEWS PROVIDE A FETURE OF 
					RUNNINNG
						INSERT, UPDATE , DELETE ON VIEWS 
							RESTRICTED TO THE COLUMNS MENTIONED IN THE 	
								VIEW DEFINATION 
								
					
			
				
		ANY UPDATE ON VIEW 
				DIRECTLY INPACTING THE TABLE WHICH IS INVOLVED IN THE VIEW DEFINATION 
				
				IT HAS TO - AS WE ALREADY AWARE VIEWS THEM SELF DOESN'T HAVE ANY PHYSICAL TABLE LINKED.
				
		UPDATE EMPLOYEES_VIEW1 SET DEPARTMENT_ID = 50 WHERE JOB_ID = 'HR_REP' AND EMPLOYEE_ID = 203;
		
		ITS UPDATING EMPLOYEES TABLE 
		
		SELECT DEPARTMENT_ID,* FROM EMPLOYEES WHERE EMPLOYEE_ID = 203;
				
		mysql> INSERT INTO EMPLOYEES_VIEW1 VALUES(201,'NIKHIL','SARASWAT','HR_REP',50);
		ERROR 1423 (HY000): Field of view 'humanresource12.employees_view1' underlying table doesn't have a default value
		mysql> DESC EMPTEMP;
		+-------+-------------+------+-----+---------+-------+
		| Field | Type        | Null | Key | Default | Extra |
		+-------+-------------+------+-----+---------+-------+
		| ID    | int         | YES  |     | NULL    |       |
		| NAME  | varchar(20) | YES  |     | NULL    |       |
		| SAL   | int         | YES  |     | NULL    |       |
		+-------+-------------+------+-----+---------+-------+
		3 rows in set (0.00 sec)

		mysql> CREATE VIEW EMPTEMP_VIEW AS SELECT ID,NAME FROM EMPTEMP;
		Query OK, 0 rows affected (0.01 sec)

		mysql> INSERT INTO EMPTEMP_VIEW VALUES(201,'NIKHIL');
		Query OK, 1 row affected (0.02 sec)

		mysql> SELECT * FROM EMPTEMP WHERE ID = 201;
		+------+--------+------+
		| ID   | NAME   | SAL  |
		+------+--------+------+
		|  201 | NIKHIL | NULL |
		+------+--------+------+
		1 row in set (0.00 sec)		
				
	**** 

	RULES NOT TO UPDATE 
		
			* SELECT CLAUSE MAY NOT CONTAIN THE KEYWORD DISTINCT.
			* SELECT CLAUSE MAY NOT CONTAINS SUMMARY FUNCTION MEANS 
				SUM(), AVG(), MAX(), COUNT(*) 
			* SELECT CLAUSE MAY NOT CONTAINS AN ORDER BY CLAUSE 
			* SELECT CLAUSE MAY NOT CONTAIN MULTIPLE TABLE 
			* WHERE CLAUSE INSIDE THE SELECT MAY NOT CONATAIN A SUBQUERY 
			* THE QUERY MAY NOT CONTAINS THE GROUP AND HAVING CLUASE 
	
	RULES NOT TO INSERT
	
			** NOT NULL COLUMNS MUST BE THE PART OF THE SELECT QUERY.
	
	 
		
		** STRUCTURE THE DATA WHICH NEED TO PRESENT TO THE END USER 
		** RESTRICT THE ACCESS TO THE DATA
		** SUMARIZED DATA FROM DIFFERENT TABLES 
		
		
		--------------------------------------------------------
		--------------------------------------------------------
		
		select `e`.`employee_id` AS `employee_id`,`e`.`job_id` AS `job_id`,`e`.`manager_id` AS `manager_id`,`e`.`department_id` AS `department_id`,`d`.`location_id` AS `location_id`,`l`.`country_id` AS `country_id`,`e`.`first_name` AS `first_name`,`e`.`last_name` AS `last_name`,`e`.`salary` AS `salary`,`e`.`commission_pct` AS `commission_pct`,`d`.`department_name` AS `department_name`,`j`.`job_title` AS `job_title`,`l`.`city` AS `city`,`l`.`state_province` AS `state_province`,`c`.`country_name` AS `country_name`,`r`.`region_name` AS `region_name` 
		from 
		(((((`employees` `e` join `departments` `d`) join `jobs` `j`) join `locations` `l`) join `countries` `c`) join `regions` `r`) where ((`e`.`department_id` = `d`.`department_id`) and (`d`.`location_id` = `l`.`location_id`) and (`l`.`country_id` = `c`.`country_id`) and (`c`.`region_id` = `r`.`region_id`) and (`j`.`job_id` = `e`.`job_id`))
		
		
	===========================================================

SUMMARIZING : 
			VIEW CAN BE CREATED WITH SELECT QUERY 
			VIEW ARE OF 2 TYPE 
				SIMPLE - CONATAINS SINGLE TABLE  
				COMPLEX - MULTIPLE TABLE 
				
			USER CAN PERFORM 
				INSERT / UPDATE / DELETE 
					OPERATION ON VIEW WITH RESTRICTED COLUMNS WHICH ARE THE PART OF VIEW 
					
	------------------------------------------------------------------
	------------------------------------------------------------------
	------------------------------------------------------------------
	
	
		CREATE VIEW EMPDEPTLOC
			AS		
			SELECT E1.EMPLOYEE_ID,E1.FIRST_NAME,D1.DEPARTMENT_NAME,L1.STREET_ADDRESS FROM 
				EMPLOYEES E1 
				INNER JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
				INNER JOIN LOCATIONS L1 
				ON D1.LOCATION_ID = L1.LOCATION_ID ;
				
	=================================================================

		** PERMISSION 
		
			CREATE USERS AND PROVIDE THEM CERTAIN PERMISSION 
			
				TWO COMMANDS 
					
						GRANT AND REVOKE 
						
						GRANT COMMAND - PROVIDE PERMISISON 
						REVOKE COMMAND -  REMOVE THE PERMISSION 
							
		
		1) CREATE ONE USER 'SHWETA'
		
			SYNTAX : 
			
				create user username 
						identified by password;
			
				create user shweta@localhost 
					identified by shweta;
		
		2) login with new use 
			we only have access 
				to information_schema 
				
		3) grant some permisison 
			SYSTAX : 
				
					GRANT PERMISSIONS 
						ON DATABASE.TABLE 
							TO USERNAME;
							
					PERMISSION  : 
								ALL 
								SELECT 
								SELECT , INSERT, UPDATE 
								
					DATABASE.TABLE : 
								
						ALL DATABASES AND ALL TABLE
								*.* 
								
						SPECIFIC TO HUMANRESOURCE2 AND TABLE EMPLOYEES 

							HUMANRESOURCE.EMPLOYEES
							
						ALL TABLE OF HUMAN RESOURCE 

							HUMANRESOURCE2.*
							
		NEED TO PROVIDE ACCESS employees_view1
			TO USER SHWETA 
			
			
			
			GRANT SELECT,UPDATE 
				ON humanresource12.employees_view1
					TO shweta@localhost;
					
					
		REMOVE THE ACCESS : 
		
			REVOKE SELECT,UPDATE 
				ON humanresource12.employees_view1
					FROM shweta@localhost;
												
							
		GRANT ALL 
			ON *.*
				TO shweta@localhost;
			

DATA CONTROL LANGUAGE : 
					GRANT 
					REVOKE 
					
					
				
------------------------------------------------------------------------		
	
		LAST TOPIC FOR SQL : 
				
		INDEXES 
			WHICH IS CONCEPT OF MAKING SERCHING FASTER 
			
			
		SEARCH ENGINE 
			
			* PREFERED TO APPLY INDEXES ON 
				* COLUMNS MOSTLY USED AT THE TIME OF JOINS 
				* COLUMNS WHICH ARE THE PART OF TABLE AND GOING TO BE USED FOR SERCHING 
			
			INDEXES 
					CREATE A SEPERATE TABLE WITH THE COLUMN VALUES IN SORTER FORMAT 
					WITH LOCATION OF THAT PERTICULAR RECORD IN THE DATABASE 
					
					EMPID 
					101
				10000001
					103
				100000232
					104
				10002323
					102
				10000023
					106
				10000023223
					108
				2323332
					109
				34543534
			
					101	10000001	
					102 10000023
					103 100000232
					104 10002323
					106 10000023223
					108 2323332
					109 34543534

			SELECT * FROM EMPLOYEES WHERE ID = 106;
			
				* FIRST GOES AND CHECK FOR INDEXES 
				* COLUMN EXIST 
				* INDEXES TABLE 
				* CHECK FOR 106 
				* PICKED UP THE ADDRESS WHERE DATA LYES 
				* RETURN TO THE CONSOLE AS OUTPUT 
				

			PROFILING  : 
				STORES YOUR LAST EXECUTED STATEMENTS 
					
			SHOW PROFILES;
			
			SHOW PROFILE FOR QUERY 2;0
							
							
			CREATE INDEX INDEX_NAME ON TABLE(COLUMNNAME)