				
								DAY 6
								
TOPICS COVERED : 
		
			INBUILD FUNCTIONS 
						
			GROUP BY CLAUSE 
				HAVING CLAUSE 
				
----------------------------------------------------------------------------

SINGLE TABLE 

	FETCH THE RECORDS FROM THE MULTIPLE TABLES 
		
			JOINS: 
				USED TO COMBINE TWO OR MORE TABLES 
					AND RETURN THE COMBINATION OF ALL THE COLUMNS FROM ALL THE TABLES 
				
				
			EMP 
				EMPID 
				EMPNAME
				EMPSALARY 
				DEPTID 
				
			DEPT 
				DEPTID 
				DEPTNAME
				DEPTLOC 
		
			** EMP + DEPT  - AFTER JOINING
				
					EMPID 
					EMPNAME
					EMPSALARY 
					DEPTID
					DEPTID 
					DEPTNAME
					DEPTLOC
				
			CERTIAN SET OF RULES :
				
					1) USER MUST INCLUDE N-1 CONDITION TO JOIN N TABLES 
					IF WE HAVE 2 TABLES TO JOIN 
						THERE MUST BE A CONDITION FOR JOINING THESE TABLES 

					3 TABLE - 2 CONDITION 
					4 TABLE - 3 CONDITION 
					
					**
					
					2) USER CAN PROVIDE AN ALIAS TO THE TABLE NAME AS WELL 
						LIKE WE PROVIDE THE ALIAS TO THE COLUMNS 
							SIMILAR WAY WE CAN PROVIDE ALIAS TO THE TABLES 
							
						
					FIRST_NAME AS NAME
					
					
					SELECT * FROM EMPLOYEES E1;
					
					E1 IS ANOTHER NAME TO THE TABLE EMPLOYEES FOR THE CURRENT QUERY 

					CERTAIN COLUMN 

						SELECT E1.FIRST_NAME,E1.SALARY 
							FROM 
								EMPLOYEES E1;
								
						{
							VAR I = 34;
							STRING VAR1 = 'RAHUL'
						}
						OBJ O1 
						
						O1.I
						O1.VAR1
						
------------------------------------------------------------------- 
							
							KEY WORD : JOIN 
						
						
				TABLE1 JOIN TABLE2 
				
				
VARIOUS TYPE OF JOIN :- 

*** NEED TO FETCH ALL THE RECORDS FROM EMPLOYEES AND DEPARTMENTS BASED ON THE CONDITION DEPARTMENT_ID OF EMPLOYEE MATCHES WITH DEPARTMENT_ID OF THE DEPARTMENTS 

	** NEED TO FETCH EMPLOYEES DETAILS WITH THERE DEPARTMENT NAMES....
	
		CONDITION : DEPARTMENT_ID EMP AND DEPT 
		
INNER JOIN : 
		
			* JOIN WHICH RETURN THE ROWS MATCHES THE CONDITION 
		
		SYNTAX : 
			
	SELECT 
		* 
		FROM 
			EMPLOYEES 
			INNER JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
						
		----------------------------------------------------				
			CREATE TABLE EMPDAC1
			(
			ID INT,
			NAME VARCHAR(20),
			SALARY INT,
			DEPTID INT
			);
			
			CREATE TABLE DEPTDAC1
			(
			DEPTID INT,
			DEPTNAME VARCHAR(20)
			);
			
			INSERT INTO EMPDAC1 VALUES(101,'RAHUL',5000,10),(102,'RITESH',6000,20),(103,'SUNITA',7000,30),(104,'KUMAR',5000,40),(105,'JITESH',9000,50);
			
			
			INSERT INTO DEPTDAC1 VALUES(10,'HR'),(20,'MARKETING'),(30,'FINANCE'),(40,'DEVELOPERS'),(60,'RESOURCE POOL');
								
								
								
			SELECT 
				* 
				FROM 
					EMPDAC1 
					INNER JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;					
														
			SELECT 
				* 
				FROM 
				 EMPDAC1 
					JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;		

----------------------------------------------------------------------
	
	SELECT 
		*
		FROM 
			EMPDAC1,DEPTDAC1
			WHERE 
				EMPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
-----------------------------------------------------------------------


						
INNER JOIN : 
				BASED ON THE CONDITION IT RETURNS THE COMMAN RECORDS 
				
------------------------------------------------------------------------

2) OUTER JOIN 
		- LEFT JOIN  - LEFT OUTER JOIN
		- RIGHT JOIN  - RIGHT OUTER JOIN 
		
	LEFT JOIN : 
				* RETURNS COMMAN RECORDS BASED ON THE CONDITION
				* + RETURN ALL THE RECORDS LEFT IN THE LEFT SIDE TABLE 
				WITH RIGHT SIDE TABLE COLUMN AS NULL VALUE 
				
		SELECT * 
			FROM 
				EMPDAC1
					LEFT JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
		OLDER SYNTAX : 
		
		SELECT * 
			FROM 
				EMPDAC1,(+)DEPTDAC1 
					WHERE EMPDAC1.DEPTID = DEPTDAC1.DEPTID;		
				
-------------------------------------------------------------------------

	RIGHT JOIN : 

			* RETUENS ALL THE COMMAN RECORDS BASED ON THE CONDITIONS 
			* + RETURNS ALL THE LEFT DATA FROM THE RIGHT SIDE TABLE 
			
		SELECT * 
			FROM 
				EMPDAC1 
				RIGHT JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
				
-------------------------------------------------------------------------
					
	NEED EMPLOYEE NAME, ID,SALARY , DEPARTMENT_NAME FROM THE HRDATABASE ;
	
	
		SELECT 
			CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME ,
				E1.EMPLOYEE_ID, E1.SALARY,D1.DEPARTMENT_NAME
			FROM 
				EMPLOYEES E1 
					INNER JOIN DEPARTMENTS D1 
						ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID;
				
					
		SELECT 
			CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME ,
				E1.EMPLOYEE_ID, E1.SALARY,D1.DEPARTMENT_NAME
			FROM 
				EMPLOYEES E1 
					LEFT JOIN DEPARTMENTS D1 
						ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID;			
					
					
	-================================================================

4) CROSS JOIN 

			* A JOIN WITHOUT ANY CONDITIONS 
			* RETURNS ME THE CARTESIAN PRODUCT OF THE TWO TABLES 
			
			
			SELECT * FROM EMPDAC1 JOIN DEPTDAC1 ORDER BY ID;
			
			JOIN - NEVER EVER USED IN THE INDUSTRY...
			
			CONCEPT IS VERY IMPORTANT 
				 
				 N TABLES AND N-1 CONDITION 
				 
					IN ANY SCENARION IF YOU MISSING  THE CONDITION 
						FOR JOINING TAWO TABLES 
							INTERNALLY IT WILL NOT THROW ERROR 
								BUT RETURN CATESIAN PRODUCT 
								
								
---------------------------------------------------------------------------

LET TAKE A BREAK FOR 20 MINUTE 
							9:30 
								
								
	-----------------------------------------------------------------

		JOIN : INNER JOIN 
				OUTER JOIN 
					LEFT OUTER JOIN 
					RIGHT OUTER JOIN 
				CROSS JOIN 
				
	** ORACLE : 
			ITS OWN JOIN NAMED A NATURAL JOIN 
			
			
			* NATURAL JOIN DOES NOT COMES WITH CONDITION 
			* IT INTERNALLY MANAGE TO HAVE A CONDITION 
				IT CHECK THE TABLE COLUMN NAME OF BOTH THE TABLES 
					AND 
					IF SOME COLUMN NAMES ARE COMMAN THEN 
						IT PICK THOSE COLUMNS AS A CONDITION FOR NATURAL JOIN 
						
	BASICALLY  : 
	
	EMP 							DEPT
	EMPID 							DEPTID 
	EMPNAME							DEPTNAME
	EMPSAL 
	DEPTID 
								
								
				SYTAX  

		SELECT 
			* FROM 
				EMPDAC1 
				NATURAL JOIN DEPTDAC1;
				
		CONVERT THE ABOVE SNTAX INTERNALLY 

		SELECT 
			* FROM 
				EMPDAC1 
				JOIN DEPTDAC1 ON ENPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
				
		COLUMNS MATCHED 
			CONDITION WITH AND OPERATOR 
			
			* IF ANYCASE NONE OF THE COLUMNS NAME MATCHES
				THEN DO THE CROSS JOIN BETWEEN THE TABLES 
				
				
			* AS THIS JOIN HANDELED BY THE SYSTEM : 
				IT AUTOMATICALLY SQUEZE THE DUPLICATE COLUMN AS WELL 
				
			
			
			
			
		 SELECT * FROM EMPLOYEES E1 JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID;


		SELECT * FROM EMPLOYEES E1 NATURAL JOIN DEPARTMENTS D1	 
			
		SELECT * FROM EMPLOYEES E1 
		JOIN DEPARTMENTS D1 
		ON 
		E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
		AND 
		E1.MANAGER_ID = D1.MANAGER_ID;	
			
			
	----------------------------------------------------------------------

6) SELF JOIN 
	
			BASICALLY THIS IS USED WHEN WE HAVE A RALATION SHIP OR A LOGIC BETWEEN TWO COLUMNS OF THE SAME TABLE 
			
			SIGLE TABLE 
					THERE MUST BE TWO COLUMN WHICH ARE SOMEHOW RELATES TO EACH OTHER 
					
			EXAMPLE 
				EMPLOYEES 
					EMPLOYEE_ID 
					FIRST_NAME 
					LAST_NAME 
					SALARY 
					MANAGER_ID 
			
			TABLE : ALL THE EMPLOYEES MUST HAVE A EMPLOYEE ID 
					EITHER ITS TERTER, DEVELOPER, LEAD, MANGAER, STAFF......
					
					MANAGER > LEADING A TEAM OF MEMBERS 
					
					101 RAHUL 8000 REPORTGIN TO RITESH 
					103 RITESH 900000 REPORTING TO NIKHIL 
					104 NIKHIL 3400000 -----
					
					101 RAHUL 8000    103
					103 RITESH 900000 104
					104 NIKHIL 3400000 NULL
					
		*** 
			PROVIDES A REPORT WITH EMPLOYEES DETAILS AND THEIR MANAGER NAMES 
			STPE 1 : 
			
					101 RAHUL 8000    103
					
			STEP 2: 
					MANAGER ID 103 
					
			STEP 3 : 
						CHECK WITH EMPLOYEE TABLE EMPLOYEE_ID COLUMN 
						
						
			STEP 4 : 
					 103 RITESH 900000 104
			
			
			STEP 5 : COMBINATION OF STEP 1 AND STEP 4 
				
					
				101 RAHUL 8000    103    	103 RITESH 900000 104
				
	-------------------------------------------------------------


		SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,E1.SALARY,
					E2.FIRST_NAME AS MANAGERNAME			
				FROM 
					EMPLOYEES E1
						INNER JOIN EMPLOYEES E2 ON E1.MANAGER_ID = E2.EMPLOYEE_ID;
						
-------------------------------------------------------------------------

CONSIDERING WE MAY MULTIPLE JOIN AND THERE MAY BE MANY TABLE EXIST WHICH ARE RELATION SHIPS 

QUESTION 1) 

NEED TO FIND ALL THE RECORDS OF THE EMPLOYEES WITH THIR DEPARTMENTNAME , LOCATION AND BELONGING COUNTRY ....
	JUST MAKE SURE TO RETURN ON DEPARTMENTS 20,40,80

	1) 
	EMPLOYEES  
		>>>> DEPARTMENT_ID 
	DEPARTMETS
		>>>>  LOCATION_ID
	LOCATIONS
		>>>> COUNTRY_ID 
	COUNTRIES 
	2) CONDITION 
		20,40,80 
	
	
	
	
SELECT E1.FIRST_NAME,E1.SALARY,E1.DEPARTMENT_ID,D1.DEPARTMENT_NAME,
	L1.street_address, L1.city,C1.country_name			
	FROM 
	EMPLOYEES E1 
	INNER JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
	INNER JOIN LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID 
	INNER JOIN COUNTRIES C1 ON L1.COUNTRY_ID = C1.COUNTRY_ID
	WHERE D1.DEPARTMENT_ID IN (20,40,80)
	ORDER BY E1.FIRST_NAME
						
						
	EXECUTION PLAN : 
			1) WHERE CLAUSE NEED TO BE EXECUTED FIRST 
			2) PULL DEPARTMENT TABLE IN TO TEMP WITH ONLY RECORDS 20,40,80 
			3) REST OF ALL THE TABLE , EMPLOYEES, COUNTRIES, LOCATIONS 
				be a part of temp memory 
			4) EMP WITH DEPT - T1 
			5) T1 JOIN LOCATION - T2 
			6) T2 JOIN COUNTRIES - T3 
			7) ORDER BY PERFORMED ON T3 
			8) RETURN T3 AS AN OUTPUT FOR CONSOLE 
			9) FREE TEMP MEMORY T1,T2,T3,EMPLOYEES, DEPARMTNET, LOCATION, COUNTRIES 
			
			
			
			
			
						
						
						
						
						
						
						
						
						
						
------------------------------------------------------------------------
OLDER SYNTAX : 

SELECT E1.FIRST_NAME,E1.SALARY,E1.DEPARTMENT_ID,D1.DEPARTMENT_NAME,
	L1.street_address, L1.city,C1.country_name			
	FROM 
	EMPLOYEES E1,DEPARTMENTS D1,LOCATIONS L1,COUNTRIES C1
	WHERE 
		E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
		AND 
		D1.LOCATION_ID = L1.LOCATION_ID
		AND 
		L1.COUNTRY_ID = C1.COUNTRY_ID
		AND 
		D1.DEPARTMENT_ID IN (20,40,80)
	ORDER BY E1.FIRST_NAME

-------------------------------------------------------------------------


*** 

	INNER JOIN 
			EQUIJOIN   ---- CONDITION WITH EQUALS OPERATORS 
			E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
			
			NON EQUIJOIN 
			JOIN PERFORMED BASED ON SOME OTHER OPERATORS THEN EQUALS 
			
			EMPLOYEES AND SALGRADE 
			
			E1.SALARY BETWEEN S1.LOWSALARY AND S1.HIGHSALARY
				
	OUTER JOIN 
			RIGHT JOIN  AND RIGHT OUTER JOIN 
			LEFT JOIN AND LEFT OUTER JOIN 
	NATURAL JOIN 
	CROSS JOIN 
	SELF JOIN 

*** FULL OUTER JOIN 
	
				WHICH IS A PART OF ORACLE 
				
		SELECT 
			* 
			FROM 
				EMPLOYEES E1
					FULL OUTER JOIN 
						DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					-
					-
					
		COMBINATION OF LEFT AND RIGHT 
		
		* RETURN ALL THE COMMAN RECORDS 
		* + RETURN ALL THE LEFT RECORDS IN THE LEFT SIDE TABLE 
		* + RETURN ALL THE LEFT RECORDS IN THE RIGHT SIDE TABLE 
		
		
		
		
		SELECT 
			* 
			FROM 
				EMPLOYEES E1
					FULL OUTER JOIN 
						DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID


		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					LEFT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
						
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					RIGHT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
				
			
----- UNION AND UNION ALL 

		UNION AND UNION ALL ARE USED TO JOIN TWO OR MORE QUERIES OUTPUT 
			
			* NUMBER OF COLUMNS IN THE QUERIES MUST BE SAME 
			* STRUCTURE OF COLUMNS IN SELECT MUST BE SAME 
				-- ITS THE RESTRICTION OF STANDARIZED DATABASES...
					
			
		** 
			UNION : SQUEZE THE SIMILAR DATA 
					REMOVE THE DATA DUPLICACY 
			
			
		** 
			UNION ALL
					RETURN ALL THE ROWS 
					
					
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					LEFT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
		UNION		
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					RIGHT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID;	
			
			
			
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					LEFT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
		UNION ALL	
		
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					RIGHT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID;		
			
			
--------------------------------------------------------------------------

	COMPLETE SYNTAX 
	
	
		
	SELECT 
		D1.DEPARTMENT_NAME,L1.STREET_ADDRESS,C1.COUNTRY_NAME,COUNT(*) EMPLOYEECOUNT,SUM(E1.SALARY) TOTALSALARY
		FROM 
			EMPLOYEES E1 
				INNER JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
				INNER JOIN LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID 
				INNER JOIN COUNTRIES C1 ON L1.COUNTRY_ID = C1.COUNTRY_ID
					WHERE D1.DEPARTMENT_ID IN (20,40,80)
						GROUP BY D1.DEPARTMENT_NAME,L1.STREET_ADDRESS,C1.COUNTRY_NAME
							HAVING SUM(E1.SALARY) > 10000			
								ORDER BY TOTALSALARY
			
-------------------------------------------------------------------

JOINING TABLE :::


	SUBQUERIES : 
				ARE THE QUESRIES WHICH ARE THE PART OF THE MAIN QUERY 
				
				* SUB QUERY ALWAYS EXECUED FIRST 
				* RETURN THE OUTPUT IN THE BRACKET 
				* OUTER OR MAIN QUERY EXECUTED....
				
		
		*** 
			EXAMPLE : 
				NEED TO FIND ALL THE EMPLOYEES 
					BELONGS TO DEPARTMENT NAME Human Resources
					
				1) DEPARTMENT_ID OF DEPARTMENT NAMED AS Human Resources
				2) FIRE A QUERY ON EMPLOYEES TO COMPARE THE DEPARTMENT_ID 
				
			
		1) DEPARTMENT_ID OF DEPARTMENT NAMED AS Human Resources

			SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Human Resources';
			
		2) FIRE A QUERY ON EMPLOYEES TO COMPARE THE DEPARTMENT_ID 
			
			SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = ???
			OUTPUT OF FIRST QUERY 
			
	CONCEPT OF SUBQUERY 

	SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID = (
								SELECT DEPARTMENT_ID 
									FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Human Resources');
	
	EXECUTION l:
		
			SUBQUERY EXECUTED FIRST 
				AND REPLACE THE VALUES INLINE 
				
	SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID = (40);		
				
				
				
	*** SUB QUERY RETURNING MORE THEN 1 VALUES 
		MAKE SURE NOT TO USE EQUALS OPERATOR 
		
			IN 
			
	SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
									FROM DEPARTMENTS WHERE DEPARTMENT_NAME IN ('Human Resources','Accounting'));		
	
			
		SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID = (40,110);	
			
			
	SUBQUERIES : 
			AS A PART OF THE MAIN QUERY FOR EXECUTIONS 				